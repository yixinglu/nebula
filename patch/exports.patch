diff --git a/.gitignore b/.gitignore
index e95bff2..a85340b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -20,6 +20,7 @@ gen-*
 CPackConfig.cmake
 CPackSourceConfig.cmake
 CMakeCache.txt
+nebula-common-config.cmake
 Makefile
 cmake_install.cmake
 CTestTestfile.cmake
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 98b0ea4..b228742 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -93,6 +93,7 @@ set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "_build")
 # Set the project home dir
 set(NEBULA_HOME ${CMAKE_CURRENT_SOURCE_DIR})
 add_definitions(-DNEBULA_HOME=${NEBULA_HOME})
+set(PACKAGE_NAME "nebula-common")
 
 if (NEBULA_BUILD_VERSION)
     add_definitions(-DNEBULA_BUILD_VERSION=${NEBULA_BUILD_VERSION})
@@ -297,6 +298,12 @@ endmacro()
 # including the precompiled header, a.k.a Base.h.gch, and thrift headers.
 macro(nebula_add_library name type)
     add_library(${name} ${type} ${ARGN})
+    export(
+        TARGETS ${name}
+        NAMESPACE "common_"
+        APPEND
+        FILE ${CMAKE_BINARY_DIR}/${PACKAGE_NAME}-config.cmake
+    )
     if (PCHSupport_FOUND)
         add_dependencies(
             ${name}
@@ -316,9 +323,7 @@ macro(nebula_add_library name type)
 endmacro()
 
 include_directories(AFTER ${NEBULA_HOME}/src)
-include_directories(AFTER src/interface)
 include_directories(AFTER ${CMAKE_CURRENT_BINARY_DIR}/src)
-include_directories(AFTER ${CMAKE_CURRENT_BINARY_DIR}/src/interface)
 
 set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -L ${NEBULA_THIRDPARTY_ROOT}/lib")
 set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -L ${NEBULA_THIRDPARTY_ROOT}/lib64")
@@ -429,10 +434,7 @@ IF(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/.git/")
     # Create the pre-commit hook every time we run cmake
     message(STATUS "Create the pre-commit hook")
     set(PRE_COMMIT_HOOK ${CMAKE_CURRENT_SOURCE_DIR}/.git/hooks/pre-commit)
-    execute_process(
-        COMMAND
-        "rm" "-f" ${PRE_COMMIT_HOOK}
-    )
+    execute_process(COMMAND "rm" "-f" ${PRE_COMMIT_HOOK})
     execute_process(
         COMMAND
         "ln" "-s" ${CMAKE_CURRENT_SOURCE_DIR}/.linters/cpp/hooks/pre-commit.sh ${PRE_COMMIT_HOOK}
@@ -470,5 +472,9 @@ set(CPACK_RPM_EXCLUDE_FROM_AUTO_FILELIST_ADDITION /usr/local)
 
 include(CPack)
 
+# Remove the existing target exporting file
+execute_process(COMMAND "rm" "-f" "${CMAKE_BINARY_DIR}/${PACKAGE_NAME}-config.cmake")
+
 add_subdirectory(src)
 
+export(PACKAGE ${PACKAGE_NAME})
diff --git a/cmake/ThriftGenerate.cmake b/cmake/ThriftGenerate.cmake
index 13a4fea..107acc6 100644
--- a/cmake/ThriftGenerate.cmake
+++ b/cmake/ThriftGenerate.cmake
@@ -96,6 +96,13 @@ add_library(
   OBJECT
   ${${file_name}-cpp2-SOURCES}
 )
+export(
+  TARGETS "${file_name}_thrift_obj"
+  NAMESPACE "common_"
+  APPEND
+  FILE ${CMAKE_BINARY_DIR}/${PACKAGE_NAME}-config.cmake
+)
+
 add_custom_target(${file_name}_thrift_headers DEPENDS ${${file_name}-cpp2-HEADERS})
 if(NOT "${file_name}" STREQUAL "common")
     add_dependencies(
diff --git a/src/base/CMakeLists.txt b/src/base/CMakeLists.txt
index faa46eb..e304be9 100644
--- a/src/base/CMakeLists.txt
+++ b/src/base/CMakeLists.txt
@@ -1,4 +1,4 @@
-add_library(
+nebula_add_library(
     base_obj OBJECT
     Base.cpp
     Cord.cpp
diff --git a/src/clients/graph/GraphClient.h b/src/clients/graph/GraphClient.h
index 00b81c7..a2f56fc 100644
--- a/src/clients/graph/GraphClient.h
+++ b/src/clients/graph/GraphClient.h
@@ -8,7 +8,7 @@
 #define CLIENTS_GRAPH_GRAPHCLIENT_H_
 
 #include "base/Base.h"
-#include "gen-cpp2/GraphServiceAsyncClient.h"
+#include "interface/gen-cpp2/GraphServiceAsyncClient.h"
 
 namespace nebula {
 namespace graph {
diff --git a/src/clients/meta/MetaClient.cpp b/src/clients/meta/MetaClient.cpp
index 2b2cdcb..8514525 100644
--- a/src/clients/meta/MetaClient.cpp
+++ b/src/clients/meta/MetaClient.cpp
@@ -5,6 +5,7 @@
  */
 
 #include "base/Base.h"
+#include <folly/hash/Hash.h>
 #include "clients/meta/MetaClient.h"
 #include "time/Duration.h"
 #include "network/NetworkUtils.h"
@@ -569,6 +570,28 @@ folly::Future<StatusOr<GraphSpaceID>> MetaClient::createSpace(std::string name,
     return future;
 }
 
+
+StatusOr<PartitionID> MetaClient::partId(GraphSpaceID spaceId, const VertexID id) const {
+    auto status = partsNum(spaceId);
+    if (!status.ok()) {
+        return Status::Error("Space not found, spaceid: %d", spaceId);
+    }
+
+    auto numParts = status.value();
+    // If the length of the id is 8, we will treat it as int64_t to be compatible
+    // with the version 1.0
+    uint64_t vid = 0;
+    if (id.size() == 8) {
+        memcpy(static_cast<void*>(&vid), id.data(), 8);
+    } else {
+        vid = folly::hash::fnv64_buf(id.data(), id.size());
+    }
+    PartitionID pId = vid % numParts + 1;
+    CHECK_GT(pId, 0U);
+    return pId;
+}
+
+
 folly::Future<StatusOr<std::vector<SpaceIdName>>> MetaClient::listSpaces() {
     cpp2::ListSpacesReq req;
     folly::Promise<StatusOr<std::vector<SpaceIdName>>> promise;
@@ -910,7 +933,7 @@ bool MetaClient::checkSpaceExistInCache(const HostAddr& host,
     return false;
 }
 
-StatusOr<int32_t> MetaClient::partsNum(GraphSpaceID spaceId) {
+StatusOr<int32_t> MetaClient::partsNum(GraphSpaceID spaceId) const {
     folly::RWSpinLock::ReadHolder holder(localCacheLock_);
     auto it = localCache_.find(spaceId);
     if (it == localCache_.end()) {
diff --git a/src/clients/meta/MetaClient.h b/src/clients/meta/MetaClient.h
index 4ecc110..d85f22a 100644
--- a/src/clients/meta/MetaClient.h
+++ b/src/clients/meta/MetaClient.h
@@ -11,7 +11,7 @@
 #include <folly/executors/IOThreadPoolExecutor.h>
 #include <folly/RWSpinLock.h>
 #include <gtest/gtest_prod.h>
-#include "gen-cpp2/MetaServiceAsyncClient.h"
+#include "interface/gen-cpp2/MetaServiceAsyncClient.h"
 #include "base/Status.h"
 #include "base/StatusOr.h"
 #include "meta/Common.h"
@@ -317,7 +317,9 @@ public:
     bool checkSpaceExistInCache(const HostAddr& host,
                                 GraphSpaceID spaceId);
 
-    StatusOr<int32_t> partsNum(GraphSpaceID spaceId);
+    StatusOr<int32_t> partsNum(GraphSpaceID spaceId) const;
+
+    StatusOr<PartitionID> partId(GraphSpaceID spaceId, VertexID id) const;
 
     StatusOr<std::shared_ptr<const SchemaProviderIf>>
     getTagSchemaFromCache(GraphSpaceID spaceId, TagID tagID, SchemaVer ver = -1);
@@ -440,8 +442,8 @@ private:
     SpaceEdgeTypeNameMap  spaceEdgeIndexByType_;
     SpaceNewestTagVerMap  spaceNewestTagVerMap_;
     SpaceNewestEdgeVerMap spaceNewestEdgeVerMap_;
-    SpaceAllEdgeMap      spaceAllEdgeMap_;
-    folly::RWSpinLock     localCacheLock_;
+    SpaceAllEdgeMap       spaceAllEdgeMap_;
+    mutable folly::RWSpinLock     localCacheLock_;
     MetaChangedListener*  listener_{nullptr};
     folly::RWSpinLock     listenerLock_;
     std::atomic<ClusterID> clusterId_{0};
diff --git a/src/clients/storage/GeneralStorageClient.cpp b/src/clients/storage/GeneralStorageClient.cpp
index 8011b60..d288b35 100644
--- a/src/clients/storage/GeneralStorageClient.cpp
+++ b/src/clients/storage/GeneralStorageClient.cpp
@@ -16,8 +16,8 @@ GeneralStorageClient::get(GraphSpaceID space,
                           folly::EventBase* evb) {
     auto status = clusterIdsToHosts(space,
                                     std::move(keys),
-                                    [] (const std::string& v) {
-        return std::hash<std::string>{}(v);
+                                    [] (const std::string& v) -> const std::string& {
+        return v;
     });
 
     if (!status.ok()) {
@@ -50,8 +50,8 @@ GeneralStorageClient::put(GraphSpaceID space,
                           folly::EventBase* evb) {
     auto status = clusterIdsToHosts(space,
                                     std::move(kvs),
-                                    [] (const KeyValue& v) {
-        return std::hash<std::string>{}(v.key);
+                                    [] (const KeyValue& v) -> const std::string& {
+        return v.key;
     });
 
     if (!status.ok()) {
diff --git a/src/clients/storage/GeneralStorageClient.h b/src/clients/storage/GeneralStorageClient.h
index c50392d..e2c4937 100644
--- a/src/clients/storage/GeneralStorageClient.h
+++ b/src/clients/storage/GeneralStorageClient.h
@@ -9,7 +9,7 @@
 
 #include "base/Base.h"
 #include <gtest/gtest_prod.h>
-#include "gen-cpp2/GeneralStorageServiceAsyncClient.h"
+#include "interface/gen-cpp2/GeneralStorageServiceAsyncClient.h"
 #include "datatypes/KeyValue.h"
 #include "clients/storage/StorageClientBase.h"
 #include "clients/meta/MetaClient.h"
diff --git a/src/clients/storage/GraphStorageClient.cpp b/src/clients/storage/GraphStorageClient.cpp
index b354f7d..eba01f4 100644
--- a/src/clients/storage/GraphStorageClient.cpp
+++ b/src/clients/storage/GraphStorageClient.cpp
@@ -21,7 +21,7 @@ GraphStorageClient::getNeighbors(GraphSpaceID space,
                                  folly::EventBase* evb) {
     auto status = clusterIdsToHosts(space,
                                     std::move(vertices),
-                                    [](const VertexID& v) {
+                                    [](const VertexID& v) -> const VertexID& {
         return v;
     });
 
@@ -62,7 +62,7 @@ GraphStorageClient::addVertices(GraphSpaceID space,
                                 folly::EventBase* evb) {
     auto status = clusterIdsToHosts(space,
                                     std::move(vertices),
-                                    [](const cpp2::NewVertex& v) {
+                                    [](const cpp2::NewVertex& v) -> const VertexID& {
         return v.get_id();
     });
 
@@ -99,7 +99,7 @@ GraphStorageClient::addEdges(GraphSpaceID space,
                              folly::EventBase* evb) {
     auto status = clusterIdsToHosts(space,
                                     std::move(edges),
-                                    [](const cpp2::NewEdge& e) {
+                                    [](const cpp2::NewEdge& e) -> const VertexID& {
         return e.get_key().get_src();
     });
 
@@ -136,7 +136,7 @@ GraphStorageClient::getVertexProps(GraphSpaceID space,
                                    folly::EventBase* evb) {
     auto status = clusterIdsToHosts(space,
                                     std::move(vertices),
-                                    [](const VertexID& v) {
+                                    [](const VertexID& v) -> const VertexID& {
         return v;
     });
 
@@ -175,7 +175,7 @@ GraphStorageClient::getEdgeProps(GraphSpaceID space,
                                  folly::EventBase* evb) {
     auto status = clusterIdsToHosts(space,
                                     std::move(edges),
-                                    [](const cpp2::EdgeKey& v) {
+                                    [](const cpp2::EdgeKey& v) -> const VertexID& {
         return v.get_src();
     });
 
@@ -212,7 +212,7 @@ GraphStorageClient::deleteEdges(GraphSpaceID space,
                                 folly::EventBase* evb) {
     auto status = clusterIdsToHosts(space,
                                     std::move(edges),
-                                    [](const cpp2::EdgeKey& v) {
+                                    [](const cpp2::EdgeKey& v) -> const VertexID& {
         return v.get_src();
     });
 
@@ -244,7 +244,9 @@ folly::SemiFuture<StorageRpcResponse<cpp2::ExecResponse>>
 GraphStorageClient::deleteVertices(GraphSpaceID space,
                                    std::vector<VertexID> ids,
                                    folly::EventBase* evb) {
-    auto status = clusterIdsToHosts(space, std::move(ids), [](const VertexID& v) {
+    auto status = clusterIdsToHosts(space,
+                                    std::move(ids),
+                                    [](const VertexID& v) -> const VertexID& {
         return v;
     });
 
@@ -282,7 +284,8 @@ GraphStorageClient::updateVertex(GraphSpaceID space,
                                  folly::EventBase* evb) {
     std::pair<HostAddr, cpp2::UpdateVertexRequest> request;
 
-    auto status = partId(space, vertexId);
+    DCHECK(!!metaClient_);
+    auto status = metaClient_->partId(space, vertexId);
     if (!status.ok()) {
         return folly::makeFuture<StatusOr<storage::cpp2::UpdateResponse>>(status.status());
     }
@@ -328,7 +331,8 @@ GraphStorageClient::updateEdge(GraphSpaceID space,
                                folly::EventBase* evb) {
     std::pair<HostAddr, cpp2::UpdateEdgeRequest> request;
 
-    auto status = partId(space, edgeKey.get_src());
+    DCHECK(!!metaClient_);
+    auto status = metaClient_->partId(space, edgeKey.get_src());
     if (!status.ok()) {
         return folly::makeFuture<StatusOr<storage::cpp2::UpdateResponse>>(status.status());
     }
@@ -369,9 +373,8 @@ GraphStorageClient::getUUID(GraphSpaceID space,
                             const std::string& name,
                             folly::EventBase* evb) {
     std::pair<HostAddr, cpp2::GetUUIDReq> request;
-    std::hash<std::string> hashFunc;
-    auto hashValue = hashFunc(name);
-    auto status = partId(space, hashValue);
+    DCHECK(!!metaClient_);
+    auto status = metaClient_->partId(space, name);
     if (!status.ok()) {
         return folly::makeFuture<StatusOr<cpp2::GetUUIDResp>>(status.status());
     }
diff --git a/src/clients/storage/GraphStorageClient.h b/src/clients/storage/GraphStorageClient.h
index 3cc025f..65e9f4f 100644
--- a/src/clients/storage/GraphStorageClient.h
+++ b/src/clients/storage/GraphStorageClient.h
@@ -9,7 +9,7 @@
 
 #include "base/Base.h"
 #include <gtest/gtest_prod.h>
-#include "gen-cpp2/GraphStorageServiceAsyncClient.h"
+#include "interface/gen-cpp2/GraphStorageServiceAsyncClient.h"
 #include "clients/storage/StorageClientBase.h"
 
 namespace nebula {
diff --git a/src/clients/storage/StorageClientBase.h b/src/clients/storage/StorageClientBase.h
index 955aeb7..dedec26 100644
--- a/src/clients/storage/StorageClientBase.h
+++ b/src/clients/storage/StorageClientBase.h
@@ -123,21 +123,19 @@ protected:
     >
     clusterIdsToHosts(GraphSpaceID spaceId, Container&& ids, GetIdFunc f) const;
 
-    // Calculate the partition id for the given vertex id
-    StatusOr<PartitionID> partId(GraphSpaceID spaceId, int64_t id) const;
-
     virtual StatusOr<meta::PartHosts> getPartHosts(GraphSpaceID spaceId,
                                                    PartitionID partId) const {
         CHECK(metaClient_ != nullptr);
         return metaClient_->getPartHostsFromCache(spaceId, partId);
     }
 
+protected:
+    meta::MetaClient* metaClient_{nullptr};
+
 private:
     std::shared_ptr<folly::IOThreadPoolExecutor> ioThreadPool_;
     std::unique_ptr<thrift::ThriftClientManager<ClientType>> clientsMan_;
 
-    meta::MetaClient* metaClient_{nullptr};
-
     mutable folly::RWSpinLock leadersLock_;
     mutable std::unordered_map<std::pair<GraphSpaceID, PartitionID>, HostAddr> leaders_;
 };
diff --git a/src/clients/storage/StorageClientBase.inl b/src/clients/storage/StorageClientBase.inl
index 2d430d4..f8ac3c7 100644
--- a/src/clients/storage/StorageClientBase.inl
+++ b/src/clients/storage/StorageClientBase.inl
@@ -78,8 +78,8 @@ template<typename ClientType>
 StorageClientBase<ClientType>::StorageClientBase(
     std::shared_ptr<folly::IOThreadPoolExecutor> threadPool,
     meta::MetaClient* metaClient)
-        : ioThreadPool_(threadPool)
-        , metaClient_(metaClient) {
+        : metaClient_(metaClient)
+        , ioThreadPool_(threadPool) {
     clientsMan_ = std::make_unique<thrift::ThriftClientManager<ClientType>>();
 }
 
@@ -307,22 +307,6 @@ folly::Future<StatusOr<Response>> StorageClientBase<ClientType>::getResponse(
 }
 
 
-template<typename ClientType>
-StatusOr<PartitionID> StorageClientBase<ClientType>::partId(GraphSpaceID spaceId,
-                                                            int64_t id) const {
-    CHECK(metaClient_ != nullptr);
-    auto status = metaClient_->partsNum(spaceId);
-    if (!status.ok()) {
-        return Status::Error("Space not found, spaceid: %d", spaceId);
-    }
-
-    auto parts = status.value();
-    auto s = ((static_cast<uint64_t>(id)) % parts + 1);
-    CHECK_GT(s, 0U);
-    return s;
-}
-
-
 template<typename ClientType>
 template<class Container, class GetIdFunc>
 StatusOr<
@@ -345,7 +329,8 @@ StorageClientBase<ClientType>::clusterIdsToHosts(GraphSpaceID spaceId,
         >
     > clusters;
     for (auto& id : ids) {
-        auto status = partId(spaceId, f(id));
+        CHECK(!!metaClient_);
+        auto status = metaClient_->partId(spaceId, f(id));
         if (!status.ok()) {
             return status;
         }
diff --git a/src/datatypes/Date.h b/src/datatypes/Date.h
index e120aaa..defed5e 100644
--- a/src/datatypes/Date.h
+++ b/src/datatypes/Date.h
@@ -16,6 +16,12 @@ struct Date {
     int8_t month;
     int8_t day;
 
+    void clear() {
+        year = 0;
+        month = 0;
+        day = 0;
+    }
+
     bool operator==(const Date& rhs) const {
         return year == rhs.year &&
                month == rhs.month &&
@@ -34,6 +40,17 @@ struct DateTime {
     int32_t microsec;
     int32_t timezone;
 
+    void clear() {
+        year = 0;
+        month = 0;
+        day = 0;
+        hour = 0;
+        minute = 0;
+        sec = 0;
+        microsec = 0;
+        timezone = 0;
+    }
+
     bool operator==(const DateTime& rhs) const {
         return year == rhs.year &&
                month == rhs.month &&
diff --git a/src/datatypes/DateOps.h b/src/datatypes/DateOps.h
new file mode 100644
index 0000000..7684c4d
--- /dev/null
+++ b/src/datatypes/DateOps.h
@@ -0,0 +1,608 @@
+/* Copyright (c) 2020 vesoft inc. All rights reserved.
+ *
+ * This source code is licensed under Apache 2.0 License,
+ * attached with Common Clause Condition 1.0, found in the LICENSES directory.
+ */
+
+#ifndef DATATYPES_DATEOPS_H_
+#define DATATYPES_DATEOPS_H_
+
+#include "base/Base.h"
+
+#include "interface/gen-cpp2/common_types.h"
+
+#include <thrift/lib/cpp2/GeneratedSerializationCodeHelper.h>
+#include <thrift/lib/cpp2/gen/module_types_tcc.h>
+#include <thrift/lib/cpp2/protocol/ProtocolReaderStructReadState.h>
+
+#include "datatypes/Date.h"
+
+namespace apache {
+namespace thrift {
+
+/**************************************
+ *
+ * Ops for class Date
+ *
+ *************************************/
+namespace detail {
+
+template <>
+struct TccStructTraits<nebula::Date> {
+    static void translateFieldName(
+            FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
+            FOLLY_MAYBE_UNUSED int16_t& fid,
+            FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
+        if (_fname == "year") {
+            fid = 1;
+            _ftype = apache::thrift::protocol::T_I16;
+        } else if (_fname == "month") {
+            fid = 2;
+            _ftype = apache::thrift::protocol::T_BYTE;
+        } else if (_fname == "day") {
+            fid = 3;
+            _ftype = apache::thrift::protocol::T_BYTE;
+        }
+    }
+};
+
+}  // namespace detail
+
+
+template<>
+inline void Cpp2Ops<nebula::Date>::clear(nebula::Date* obj) {
+  return obj->clear();
+}
+
+
+template<>
+inline constexpr protocol::TType Cpp2Ops<nebula::Date>::thriftType() {
+  return apache::thrift::protocol::T_STRUCT;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Date>::write(Protocol* proto, nebula::Date const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->writeStructBegin("Date");
+
+    xfer += proto->writeFieldBegin("year", apache::thrift::protocol::T_I16, 1);
+    xfer += detail::pm::protocol_methods<type_class::integral, int16_t>
+        ::write(*proto, obj->year);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("month", apache::thrift::protocol::T_BYTE, 2);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::write(*proto, obj->month);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("day", apache::thrift::protocol::T_BYTE, 3);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::write(*proto, obj->day);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldStop();
+    xfer += proto->writeStructEnd();
+
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+void Cpp2Ops<nebula::Date>::read(Protocol* proto, nebula::Date* obj) {
+    detail::ProtocolReaderStructReadState<Protocol> readState;
+
+    readState.readStructBegin(proto);
+
+    using apache::thrift::TProtocolException;
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 0, 1, protocol::T_I16))) {
+        goto _loop;
+    }
+
+_readField_year:
+    {
+        detail::pm::protocol_methods<type_class::integral, int16_t>::read(*proto, obj->year);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 1, 2, protocol::T_BYTE))) {
+        goto _loop;
+    }
+
+_readField_month:
+    {
+        detail::pm::protocol_methods<type_class::integral, int8_t>::read(*proto, obj->month);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 2, 3, protocol::T_BYTE))) {
+        goto _loop;
+    }
+
+_readField_day:
+    {
+        detail::pm::protocol_methods<type_class::integral, int8_t>::read(*proto, obj->day);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 3, 0, protocol::T_STOP))) {
+        goto _loop;
+    }
+
+_end:
+    readState.readStructEnd(proto);
+
+    return;
+
+_loop:
+    if (readState.fieldType == apache::thrift::protocol::T_STOP) {
+        goto _end;
+    }
+    if (proto->kUsesFieldNames()) {
+        detail::TccStructTraits<nebula::Date>::translateFieldName(
+            readState.fieldName(), readState.fieldId, readState.fieldType);
+    }
+
+    switch (readState.fieldId) {
+        case 1:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_I16)) {
+                goto _readField_year;
+            } else {
+                goto _skip;
+            }
+        }
+        case 2:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_BYTE)) {
+                goto _readField_month;
+            } else {
+                goto _skip;
+            }
+        }
+        case 3:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_BYTE)) {
+                goto _readField_day;
+            } else {
+                goto _skip;
+            }
+        }
+        default:
+        {
+_skip:
+            proto->skip(readState.fieldType);
+            readState.readFieldEnd(proto);
+            readState.readFieldBeginNoInline(proto);
+            goto _loop;
+        }
+    }
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Date>::serializedSize(Protocol const* proto,
+                                               nebula::Date const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("Date");
+
+    xfer += proto->serializedFieldSize("year", apache::thrift::protocol::T_I16, 1);
+    xfer += detail::pm::protocol_methods<type_class::integral, int16_t>
+        ::serializedSize<false>(*proto, obj->year);
+
+    xfer += proto->serializedFieldSize("month", apache::thrift::protocol::T_BYTE, 2);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->month);
+
+    xfer += proto->serializedFieldSize("day", apache::thrift::protocol::T_BYTE, 3);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->day);
+
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Date>::serializedSizeZC(Protocol const* proto,
+                                                 nebula::Date const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("Date");
+
+    xfer += proto->serializedFieldSize("year", apache::thrift::protocol::T_I16, 1);
+    xfer += detail::pm::protocol_methods<type_class::integral, int16_t>
+        ::serializedSize<false>(*proto, obj->year);
+
+    xfer += proto->serializedFieldSize("month", apache::thrift::protocol::T_BYTE, 2);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->month);
+
+    xfer += proto->serializedFieldSize("day", apache::thrift::protocol::T_BYTE, 3);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->day);
+
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+
+/**************************************
+ *
+ * Ops for class DateTime
+ *
+ *************************************/
+namespace detail {
+
+template <>
+struct TccStructTraits<nebula::DateTime> {
+    static void translateFieldName(
+            FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
+            FOLLY_MAYBE_UNUSED int16_t& fid,
+            FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
+        if (_fname == "year") {
+            fid = 1;
+            _ftype = apache::thrift::protocol::T_I16;
+        } else if (_fname == "month") {
+            fid = 2;
+            _ftype = apache::thrift::protocol::T_BYTE;
+        } else if (_fname == "day") {
+            fid = 3;
+            _ftype = apache::thrift::protocol::T_BYTE;
+        } else if (_fname == "hour") {
+            fid = 4;
+            _ftype = apache::thrift::protocol::T_BYTE;
+        } else if (_fname == "minute") {
+            fid = 5;
+            _ftype = apache::thrift::protocol::T_BYTE;
+        } else if (_fname == "sec") {
+            fid = 6;
+            _ftype = apache::thrift::protocol::T_BYTE;
+        } else if (_fname == "microsec") {
+            fid = 7;
+            _ftype = apache::thrift::protocol::T_I32;
+        } else if (_fname == "timezone") {
+            fid = 8;
+            _ftype = apache::thrift::protocol::T_I32;
+        }
+    }
+};
+
+}  // namespace detail
+
+
+template<>
+inline void Cpp2Ops<nebula::DateTime>::clear(nebula::DateTime* obj) {
+  return obj->clear();
+}
+
+
+template<>
+inline constexpr protocol::TType Cpp2Ops<nebula::DateTime>::thriftType() {
+  return apache::thrift::protocol::T_STRUCT;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::DateTime>::write(Protocol* proto, nebula::DateTime const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->writeStructBegin("DateTime");
+
+    xfer += proto->writeFieldBegin("year", apache::thrift::protocol::T_I16, 1);
+    xfer += detail::pm::protocol_methods<type_class::integral, int16_t>
+        ::write(*proto, obj->year);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("month", apache::thrift::protocol::T_BYTE, 2);
+    xfer += detail::pm::protocol_methods<thrift::type_class::integral, int8_t>
+        ::write(*proto, obj->month);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("day", apache::thrift::protocol::T_BYTE, 3);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::write(*proto, obj->day);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("hour", apache::thrift::protocol::T_BYTE, 4);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::write(*proto, obj->hour);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("minute", apache::thrift::protocol::T_BYTE, 5);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::write(*proto, obj->minute);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("sec", apache::thrift::protocol::T_BYTE, 6);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::write(*proto, obj->sec);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("microsec", apache::thrift::protocol::T_I32, 7);
+    xfer += detail::pm::protocol_methods<type_class::integral, int32_t>
+        ::write(*proto, obj->microsec);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("timezone", apache::thrift::protocol::T_I32, 8);
+    xfer += detail::pm::protocol_methods<type_class::integral, int32_t>
+        ::write(*proto, obj->timezone);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldStop();
+    xfer += proto->writeStructEnd();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+void Cpp2Ops<nebula::DateTime>::read(Protocol* proto, nebula::DateTime* obj) {
+    detail::ProtocolReaderStructReadState<Protocol> readState;
+
+    readState.readStructBegin(proto);
+
+    using apache::thrift::TProtocolException;
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 0, 1, protocol::T_I16))) {
+        goto _loop;
+    }
+
+_readField_year:
+    {
+        detail::pm::protocol_methods<type_class::integral, int16_t>::read(*proto, obj->year);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 1, 2, protocol::T_BYTE))) {
+        goto _loop;
+    }
+
+_readField_month:
+    {
+        detail::pm::protocol_methods<type_class::integral, int8_t>::read(*proto, obj->month);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 2, 3, protocol::T_BYTE))) {
+        goto _loop;
+    }
+
+_readField_day:
+    {
+        detail::pm::protocol_methods<type_class::integral, int8_t>::read(*proto, obj->day);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 3, 4, protocol::T_BYTE))) {
+        goto _loop;
+    }
+
+_readField_hour:
+    {
+        detail::pm::protocol_methods<type_class::integral, int8_t>::read(*proto, obj->hour);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 4, 5, protocol::T_BYTE))) {
+        goto _loop;
+    }
+
+_readField_minute:
+    {
+        detail::pm::protocol_methods<type_class::integral, int8_t>::read(*proto, obj->minute);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 5, 6, protocol::T_BYTE))) {
+        goto _loop;
+    }
+
+_readField_sec:
+    {
+        detail::pm::protocol_methods<type_class::integral, int8_t>::read(*proto, obj->sec);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 6, 7, protocol::T_I32))) {
+        goto _loop;
+    }
+
+_readField_microsec:
+    {
+        detail::pm::protocol_methods<type_class::integral, int32_t>
+            ::read(*proto, obj->microsec);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 7, 8, protocol::T_I32))) {
+        goto _loop;
+    }
+
+_readField_timezone:
+    {
+        detail::pm::protocol_methods<type_class::integral, int32_t>
+            ::read(*proto, obj->timezone);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 8, 0, protocol::T_STOP))) {
+        goto _loop;
+    }
+
+_end:
+    readState.readStructEnd(proto);
+
+    return;
+
+_loop:
+    if (readState.fieldType == apache::thrift::protocol::T_STOP) {
+        goto _end;
+    }
+
+    if (proto->kUsesFieldNames()) {
+        detail::TccStructTraits<nebula::DateTime>::translateFieldName(
+            readState.fieldName(), readState.fieldId, readState.fieldType);
+    }
+
+    switch (readState.fieldId) {
+        case 1:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_I16)) {
+                goto _readField_year;
+            } else {
+                goto _skip;
+            }
+        }
+        case 2:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_BYTE)) {
+                goto _readField_month;
+            } else {
+                goto _skip;
+            }
+        }
+        case 3:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_BYTE)) {
+                goto _readField_day;
+            } else {
+                goto _skip;
+            }
+        }
+        case 4:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_BYTE)) {
+                goto _readField_hour;
+            } else {
+                goto _skip;
+            }
+        }
+        case 5:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_BYTE)) {
+                goto _readField_minute;
+            } else {
+                goto _skip;
+            }
+        }
+        case 6:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_BYTE)) {
+                goto _readField_sec;
+            } else {
+                goto _skip;
+            }
+        }
+        case 7:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_I32)) {
+                goto _readField_microsec;
+            } else {
+                goto _skip;
+            }
+        }
+        case 8:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_I32)) {
+                goto _readField_timezone;
+            } else {
+                goto _skip;
+            }
+        }
+        default:
+        {
+_skip:
+            proto->skip(readState.fieldType);
+            readState.readFieldEnd(proto);
+            readState.readFieldBeginNoInline(proto);
+            goto _loop;
+        }
+    }
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::DateTime>::serializedSize(Protocol const* proto,
+                                                   nebula::DateTime const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("DateTime");
+
+    xfer += proto->serializedFieldSize("year", apache::thrift::protocol::T_I16, 1);
+    xfer += detail::pm::protocol_methods<type_class::integral, int16_t>
+        ::serializedSize<false>(*proto, obj->year);
+
+    xfer += proto->serializedFieldSize("month", apache::thrift::protocol::T_BYTE, 2);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->month);
+
+    xfer += proto->serializedFieldSize("day", apache::thrift::protocol::T_BYTE, 3);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->day);
+
+    xfer += proto->serializedFieldSize("hour", apache::thrift::protocol::T_BYTE, 4);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->hour);
+
+    xfer += proto->serializedFieldSize("minute", apache::thrift::protocol::T_BYTE, 5);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->minute);
+
+    xfer += proto->serializedFieldSize("sec", apache::thrift::protocol::T_BYTE, 6);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->sec);
+
+    xfer += proto->serializedFieldSize("microsec", apache::thrift::protocol::T_I32, 7);
+    xfer += detail::pm::protocol_methods<type_class::integral, int32_t>
+        ::serializedSize<false>(*proto, obj->microsec);
+
+    xfer += proto->serializedFieldSize("timezone", apache::thrift::protocol::T_I32, 8);
+    xfer += detail::pm::protocol_methods<type_class::integral, int32_t>
+        ::serializedSize<false>(*proto, obj->timezone);
+
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::DateTime>::serializedSizeZC(Protocol const* proto,
+                                                     nebula::DateTime const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("DateTime");
+
+    xfer += proto->serializedFieldSize("year", apache::thrift::protocol::T_I16, 1);
+    xfer += detail::pm::protocol_methods<type_class::integral, int16_t>
+        ::serializedSize<false>(*proto, obj->year);
+
+    xfer += proto->serializedFieldSize("month", apache::thrift::protocol::T_BYTE, 2);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->month);
+
+    xfer += proto->serializedFieldSize("day", apache::thrift::protocol::T_BYTE, 3);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->day);
+
+    xfer += proto->serializedFieldSize("hour", apache::thrift::protocol::T_BYTE, 4);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->hour);
+
+    xfer += proto->serializedFieldSize("minute", apache::thrift::protocol::T_BYTE, 5);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->minute);
+
+    xfer += proto->serializedFieldSize("sec", apache::thrift::protocol::T_BYTE, 6);
+    xfer += detail::pm::protocol_methods<type_class::integral, int8_t>
+        ::serializedSize<false>(*proto, obj->sec);
+
+    xfer += proto->serializedFieldSize("microsec", apache::thrift::protocol::T_I32, 7);
+    xfer += detail::pm::protocol_methods<type_class::integral, int32_t>
+        ::serializedSize<false>(*proto, obj->microsec);
+
+    xfer += proto->serializedFieldSize("timezone", apache::thrift::protocol::T_I32, 8);
+    xfer += detail::pm::protocol_methods<type_class::integral, int32_t>
+        ::serializedSize<false>(*proto, obj->timezone);
+
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+}  // namespace thrift
+}  // namespace apache
+#endif  // DATATYPES_DATEOPS_H_
+
diff --git a/src/datatypes/HostAddr.h b/src/datatypes/HostAddr.h
index 893e06a..da07b1a 100644
--- a/src/datatypes/HostAddr.h
+++ b/src/datatypes/HostAddr.h
@@ -21,6 +21,11 @@ struct HostAddr {
     HostAddr() : ip(0), port(0) {}
     HostAddr(IPv4 a, Port p) : ip(a), port(p) {}
 
+    void clear() {
+        ip = 0;
+        port = 0;
+    }
+
     bool operator==(const HostAddr& rhs) const;
 };
 
diff --git a/src/datatypes/HostAddrOps.h b/src/datatypes/HostAddrOps.h
new file mode 100644
index 0000000..2ad3f24
--- /dev/null
+++ b/src/datatypes/HostAddrOps.h
@@ -0,0 +1,196 @@
+/* Copyright (c) 2020 vesoft inc. All rights reserved.
+ *
+ * This source code is licensed under Apache 2.0 License,
+ * attached with Common Clause Condition 1.0, found in the LICENSES directory.
+ */
+
+#ifndef DATATYPES_HOSTADDROPS_H_
+#define DATATYPES_HOSTADDROPS_H_
+
+#include "base/Base.h"
+
+#include "interface/gen-cpp2/common_types.h"
+
+#include <thrift/lib/cpp2/GeneratedSerializationCodeHelper.h>
+#include <thrift/lib/cpp2/gen/module_types_tcc.h>
+#include <thrift/lib/cpp2/protocol/ProtocolReaderStructReadState.h>
+
+#include "datatypes/HostAddr.h"
+
+namespace apache {
+namespace thrift {
+
+namespace detail {
+
+template <>
+struct TccStructTraits<nebula::HostAddr> {
+    static void translateFieldName(
+            FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
+            FOLLY_MAYBE_UNUSED int16_t& fid,
+            FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
+        if (_fname == "ip") {
+            fid = 1;
+            _ftype = apache::thrift::protocol::T_I32;
+        } else if (_fname == "port") {
+            fid = 2;
+            _ftype = apache::thrift::protocol::T_I32;
+        }
+    }
+};
+
+}  // namespace detail
+
+
+template <>
+inline void Cpp2Ops<nebula::HostAddr>::clear(nebula::HostAddr* obj) {
+    return obj->clear();
+}
+
+
+template<>
+inline constexpr protocol::TType Cpp2Ops<nebula::HostAddr>::thriftType() {
+    return apache::thrift::protocol::T_STRUCT;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::HostAddr>::write(Protocol* proto, nebula::HostAddr const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->writeStructBegin("HostAddr");
+
+    xfer += proto->writeFieldBegin("ip", apache::thrift::protocol::T_I32, 1);
+    xfer += detail::pm::protocol_methods<type_class::integral, nebula::IPv4>
+        ::write(*proto, obj->ip);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("port", apache::thrift::protocol::T_I32, 2);
+    xfer += detail::pm::protocol_methods<type_class::integral, nebula::Port>
+        ::write(*proto, obj->port);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldStop();
+    xfer += proto->writeStructEnd();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+void Cpp2Ops<nebula::HostAddr>::read(Protocol* proto, nebula::HostAddr* obj) {
+    detail::ProtocolReaderStructReadState<Protocol> readState;
+
+    readState.readStructBegin(proto);
+
+    using apache::thrift::TProtocolException;
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 0, 1, protocol::T_I32))) {
+        goto _loop;
+    }
+
+_readField_ip:
+    {
+        detail::pm::protocol_methods<type_class::integral, nebula::IPv4>
+            ::read(*proto, obj->ip);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 1, 2, protocol::T_I32))) {
+        goto _loop;
+    }
+
+_readField_port:
+    {
+        detail::pm::protocol_methods<type_class::integral, nebula::Port>
+            ::read(*proto, obj->port);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 2, 0, protocol::T_STOP))) {
+        goto _loop;
+    }
+
+_end:
+    readState.readStructEnd(proto);
+
+    return;
+
+_loop:
+    if (readState.fieldType == apache::thrift::protocol::T_STOP) {
+        goto _end;
+    }
+    if (proto->kUsesFieldNames()) {
+        detail::TccStructTraits<nebula::HostAddr>::translateFieldName(
+            readState.fieldName(), readState.fieldId, readState.fieldType);
+    }
+
+    switch (readState.fieldId) {
+        case 1:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_I32)) {
+                goto _readField_ip;
+            } else {
+                goto _skip;
+            }
+        }
+        case 2:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_I32)) {
+                goto _readField_port;
+            } else {
+                goto _skip;
+            }
+        }
+        default:
+        {
+_skip:
+            proto->skip(readState.fieldType);
+            readState.readFieldEnd(proto);
+            readState.readFieldBeginNoInline(proto);
+            goto _loop;
+        }
+    }
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::HostAddr>::serializedSize(Protocol const* proto,
+                                                   nebula::HostAddr const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("HostAddr");
+
+    xfer += proto->serializedFieldSize("ip", apache::thrift::protocol::T_I32, 1);
+    xfer += detail::pm::protocol_methods<type_class::integral, nebula::IPv4>
+        ::serializedSize<false>(*proto, obj->ip);
+
+    xfer += proto->serializedFieldSize("port", apache::thrift::protocol::T_I32, 2);
+    xfer += detail::pm::protocol_methods<type_class::integral, nebula::Port>
+        ::serializedSize<false>(*proto, obj->port);
+
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::HostAddr>::serializedSizeZC(Protocol const* proto,
+                                                     nebula::HostAddr const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("HostAddr");
+
+    xfer += proto->serializedFieldSize("ip", apache::thrift::protocol::T_I32, 1);
+    xfer += detail::pm::protocol_methods<type_class::integral, nebula::IPv4>
+        ::serializedSize<false>(*proto, obj->ip);
+
+    xfer += proto->serializedFieldSize("port", apache::thrift::protocol::T_I32, 2);
+    xfer += detail::pm::protocol_methods<type_class::integral, nebula::Port>
+        ::serializedSize<false>(*proto, obj->port);
+
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+}  // namespace thrift
+}  // namespace apache
+#endif  // DATATYPES_HOSTADDROPS_H_
+
diff --git a/src/datatypes/KeyValue.h b/src/datatypes/KeyValue.h
index 6feb708..7f43f29 100644
--- a/src/datatypes/KeyValue.h
+++ b/src/datatypes/KeyValue.h
@@ -26,6 +26,11 @@ struct KeyValue {
         : key(std::move(kv.first))
         , value(std::move(kv.second)) {}
 
+    void clear() {
+        key.clear();
+        value.clear();
+    }
+
     bool operator==(const KeyValue& rhs) const {
         if (key != rhs.key) {
             return false;
diff --git a/src/datatypes/KeyValueOps.h b/src/datatypes/KeyValueOps.h
new file mode 100644
index 0000000..d927319
--- /dev/null
+++ b/src/datatypes/KeyValueOps.h
@@ -0,0 +1,189 @@
+/* Copyright (c) 2020 vesoft inc. All rights reserved.
+ *
+ * This source code is licensed under Apache 2.0 License,
+ * attached with Common Clause Condition 1.0, found in the LICENSES directory.
+ */
+
+#ifndef DATATYPES_KEYVALUEOPS_H_
+#define DATATYPES_KEYVALUEOPS_H_
+
+#include "base/Base.h"
+
+#include "interface/gen-cpp2/common_types.h"
+
+#include <thrift/lib/cpp2/GeneratedSerializationCodeHelper.h>
+#include <thrift/lib/cpp2/gen/module_types_tcc.h>
+#include <thrift/lib/cpp2/protocol/ProtocolReaderStructReadState.h>
+
+#include "datatypes/KeyValue.h"
+
+namespace apache {
+namespace thrift {
+
+namespace detail {
+
+template <>
+struct TccStructTraits<nebula::KeyValue> {
+    static void translateFieldName(
+            FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
+            FOLLY_MAYBE_UNUSED int16_t& fid,
+            FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
+        if (_fname == "key") {
+            fid = 1;
+            _ftype = apache::thrift::protocol::T_STRING;
+        } else if (_fname == "value") {
+            fid = 2;
+            _ftype = apache::thrift::protocol::T_STRING;
+        }
+    }
+};
+
+}  // namespace detail
+
+
+template<>
+inline void Cpp2Ops<nebula::KeyValue>::clear(nebula::KeyValue* obj) {
+    return obj->clear();
+}
+
+
+template<>
+inline constexpr protocol::TType Cpp2Ops<nebula::KeyValue>::thriftType() {
+    return apache::thrift::protocol::T_STRUCT;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::KeyValue>::write(Protocol* proto, nebula::KeyValue const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->writeStructBegin("KeyValue");
+
+    xfer += proto->writeFieldBegin("key", apache::thrift::protocol::T_STRING, 1);
+    xfer += proto->writeBinary(obj->key);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("value", apache::thrift::protocol::T_STRING, 2);
+    xfer += proto->writeBinary(obj->value);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldStop();
+    xfer += proto->writeStructEnd();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+void Cpp2Ops<nebula::KeyValue>::read(Protocol* proto, nebula::KeyValue* obj) {
+    detail::ProtocolReaderStructReadState<Protocol> readState;
+
+    readState.readStructBegin(proto);
+
+    using apache::thrift::TProtocolException;
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 0, 1, protocol::T_STRING))) {
+        goto _loop;
+    }
+
+_readField_key:
+    {
+        proto->readBinary(obj->key);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 1, 2, protocol::T_STRING))) {
+        goto _loop;
+    }
+
+_readField_value:
+    {
+        proto->readBinary(obj->value);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 2, 0, protocol::T_STOP))) {
+        goto _loop;
+    }
+
+_end:
+    readState.readStructEnd(proto);
+
+    return;
+
+_loop:
+    if (readState.fieldType == apache::thrift::protocol::T_STOP) {
+        goto _end;
+    }
+
+    if (proto->kUsesFieldNames()) {
+        detail::TccStructTraits<nebula::KeyValue>::translateFieldName(
+            readState.fieldName(), readState.fieldId, readState.fieldType);
+    }
+
+    switch (readState.fieldId) {
+        case 1:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_STRING)) {
+                goto _readField_key;
+            } else {
+                goto _skip;
+            }
+        }
+        case 2:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_STRING)) {
+                goto _readField_value;
+            } else {
+                goto _skip;
+            }
+        }
+        default:
+        {
+_skip:
+            proto->skip(readState.fieldType);
+            readState.readFieldEnd(proto);
+            readState.readFieldBeginNoInline(proto);
+            goto _loop;
+        }
+    }
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::KeyValue>::serializedSize(Protocol const* proto,
+                                                   nebula::KeyValue const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("KeyValue");
+
+    xfer += proto->serializedFieldSize("key", apache::thrift::protocol::T_STRING, 1);
+    xfer += proto->serializedSizeBinary(obj->key);
+
+    xfer += proto->serializedFieldSize("value", apache::thrift::protocol::T_STRING, 2);
+    xfer += proto->serializedSizeBinary(obj->value);
+
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::KeyValue>::serializedSizeZC(Protocol const* proto,
+                                                     nebula::KeyValue const* obj) {
+  uint32_t xfer = 0;
+  xfer += proto->serializedStructSize("KeyValue");
+
+  xfer += proto->serializedFieldSize("key", apache::thrift::protocol::T_STRING, 1);
+  xfer += proto->serializedSizeZCBinary(obj->key);
+
+  xfer += proto->serializedFieldSize("value", apache::thrift::protocol::T_STRING, 2);
+  xfer += proto->serializedSizeZCBinary(obj->value);
+
+  xfer += proto->serializedSizeStop();
+  return xfer;
+}
+
+}  // namespace thrift
+}  // namespace apache
+#endif  // DATATYPES_KEYVALUEOPS_H_
+
diff --git a/src/datatypes/List.h b/src/datatypes/List.h
new file mode 100644
index 0000000..d4ce365
--- /dev/null
+++ b/src/datatypes/List.h
@@ -0,0 +1,42 @@
+/* Copyright (c) 2020 vesoft inc. All rights reserved.
+ *
+ * This source code is licensed under Apache 2.0 License,
+ * attached with Common Clause Condition 1.0, found in the LICENSES directory.
+ */
+
+#ifndef DATATYPES_LIST_H_
+#define DATATYPES_LIST_H_
+
+#include "base/Base.h"
+#include "datatypes/Value.h"
+
+namespace nebula {
+
+struct List {
+    std::vector<Value> values;
+
+    List() = default;
+    List(const List&) = default;
+    List(List&&) = default;
+
+    void clear() {
+        values.clear();
+    }
+
+    List& operator=(const List& rhs) {
+        values = rhs.values;
+        return *this;
+    }
+    List& operator=(List&& rhs) {
+        values = std::move(rhs.values);
+        return *this;
+    }
+
+    bool operator==(const List& rhs) const {
+        return values == rhs.values;
+    }
+};
+
+}  // namespace nebula
+#endif  // DATATYPES_LIST_H_
+
diff --git a/src/datatypes/ListOps.h b/src/datatypes/ListOps.h
new file mode 100644
index 0000000..a22efe8
--- /dev/null
+++ b/src/datatypes/ListOps.h
@@ -0,0 +1,170 @@
+/* Copyright (c) 2020 vesoft inc. All rights reserved.
+ *
+ * This source code is licensed under Apache 2.0 License,
+ * attached with Common Clause Condition 1.0, found in the LICENSES directory.
+ */
+
+#ifndef DATATYPES_LISTOPS_H_
+#define DATATYPES_LISTOPS_H_
+
+#include "base/Base.h"
+
+#include "interface/gen-cpp2/common_types.h"
+
+#include <thrift/lib/cpp2/GeneratedSerializationCodeHelper.h>
+#include <thrift/lib/cpp2/gen/module_types_tcc.h>
+#include <thrift/lib/cpp2/protocol/ProtocolReaderStructReadState.h>
+
+#include "datatypes/List.h"
+
+namespace apache {
+namespace thrift {
+
+namespace detail {
+
+template<>
+struct TccStructTraits<nebula::List> {
+    static void translateFieldName(
+            FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
+            FOLLY_MAYBE_UNUSED int16_t& fid,
+            FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
+        if (_fname == "values") {
+            fid = 1;
+            _ftype = apache::thrift::protocol::T_LIST;
+        }
+    }
+};
+
+}  // namespace detail
+
+
+template<>
+inline void Cpp2Ops<nebula::List>::clear(nebula::List* obj) {
+    return obj->clear();
+}
+
+
+template<>
+inline constexpr protocol::TType Cpp2Ops<nebula::List>::thriftType() {
+    return apache::thrift::protocol::T_STRUCT;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::List>::write(Protocol* proto, nebula::List const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->writeStructBegin("List");
+
+    xfer += proto->writeFieldBegin("values", apache::thrift::protocol::T_LIST, 1);
+    xfer += detail::pm::protocol_methods<
+            type_class::list<type_class::structure>,
+            std::vector<nebula::Value>
+        >::write(*proto, obj->values);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldStop();
+    xfer += proto->writeStructEnd();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+void Cpp2Ops<nebula::List>::read(Protocol* proto, nebula::List* obj) {
+    detail::ProtocolReaderStructReadState<Protocol> readState;
+
+    readState.readStructBegin(proto);
+
+    using apache::thrift::TProtocolException;
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 0, 1, protocol::T_LIST))) {
+        goto _loop;
+    }
+
+_readField_values:
+    {
+        obj->values = std::vector<nebula::Value>();
+        detail::pm::protocol_methods<
+                type_class::list<type_class::structure>,
+                std::vector<nebula::Value>
+            >::read(*proto, obj->values);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 1, 0, protocol::T_STOP))) {
+        goto _loop;
+    }
+
+_end:
+    readState.readStructEnd(proto);
+
+    return;
+
+_loop:
+    if (readState.fieldType == apache::thrift::protocol::T_STOP) {
+        goto _end;
+    }
+
+    if (proto->kUsesFieldNames()) {
+        detail::TccStructTraits<nebula::List>::translateFieldName(
+            readState.fieldName(), readState.fieldId, readState.fieldType);
+    }
+
+    switch (readState.fieldId) {
+        case 1:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_LIST)) {
+                goto _readField_values;
+            } else {
+                goto _skip;
+            }
+        }
+        default:
+        {
+_skip:
+            proto->skip(readState.fieldType);
+            readState.readFieldEnd(proto);
+            readState.readFieldBeginNoInline(proto);
+            goto _loop;
+        }
+    }
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::List>::serializedSize(Protocol const* proto,
+                                               nebula::List const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("List");
+
+    xfer += proto->serializedFieldSize("values", apache::thrift::protocol::T_LIST, 1);
+    xfer += detail::pm::protocol_methods<
+            type_class::list<type_class::structure>,
+            std::vector<nebula::Value>
+        >::serializedSize<false>(*proto, obj->values);
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::List>::serializedSizeZC(Protocol const* proto,
+                                                 nebula::List const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("List");
+
+    xfer += proto->serializedFieldSize("values", apache::thrift::protocol::T_LIST, 1);
+    xfer += detail::pm::protocol_methods<
+            type_class::list<type_class::structure>,
+            std::vector<nebula::Value>
+        >::serializedSize<false>(*proto, obj->values);
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+}  // namespace thrift
+}  // namespace apache
+#endif  // DATATYPES_LISTOPS_H_
+
diff --git a/src/datatypes/Map.h b/src/datatypes/Map.h
new file mode 100644
index 0000000..003bdc4
--- /dev/null
+++ b/src/datatypes/Map.h
@@ -0,0 +1,42 @@
+/* Copyright (c) 2020 vesoft inc. All rights reserved.
+ *
+ * This source code is licensed under Apache 2.0 License,
+ * attached with Common Clause Condition 1.0, found in the LICENSES directory.
+ */
+
+#ifndef DATATYPES_MAP_H_
+#define DATATYPES_MAP_H_
+
+#include "base/Base.h"
+#include "datatypes/Value.h"
+
+namespace nebula {
+
+struct Map {
+    std::unordered_map<std::string, Value> kvs;
+
+    Map() = default;
+    Map(const Map&) = default;
+    Map(Map&&) = default;
+
+    Map& operator=(const Map& rhs) {
+        kvs = rhs.kvs;
+        return *this;
+    }
+    Map& operator=(Map&& rhs) {
+        kvs = std::move(rhs.kvs);
+        return *this;
+    }
+
+    void clear() {
+        kvs.clear();
+    }
+
+    bool operator==(const Map& rhs) const {
+        return kvs == rhs.kvs;
+    }
+};
+
+}  // namespace nebula
+#endif  // DATATYPES_MAP_H_
+
diff --git a/src/datatypes/MapOps.h b/src/datatypes/MapOps.h
new file mode 100644
index 0000000..0e0fca7
--- /dev/null
+++ b/src/datatypes/MapOps.h
@@ -0,0 +1,170 @@
+/* Copyright (c) 2020 vesoft inc. All rights reserved.
+ *
+ * This source code is licensed under Apache 2.0 License,
+ * attached with Common Clause Condition 1.0, found in the LICENSES directory.
+ */
+
+#ifndef DATATYPES_MAPOPS_H_
+#define DATATYPES_MAPOPS_H_
+
+#include "base/Base.h"
+
+#include "interface/gen-cpp2/common_types.h"
+
+#include <thrift/lib/cpp2/GeneratedSerializationCodeHelper.h>
+#include <thrift/lib/cpp2/gen/module_types_tcc.h>
+#include <thrift/lib/cpp2/protocol/ProtocolReaderStructReadState.h>
+
+#include "datatypes/Map.h"
+
+namespace apache {
+namespace thrift {
+
+namespace detail {
+
+template<>
+struct TccStructTraits<nebula::Map> {
+    static void translateFieldName(
+            FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
+            FOLLY_MAYBE_UNUSED int16_t& fid,
+            FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
+        if (_fname == "kvs") {
+            fid = 1;
+            _ftype = apache::thrift::protocol::T_MAP;
+        }
+    }
+};
+
+}  // namespace detail
+
+
+template<>
+inline void Cpp2Ops<nebula::Map>::clear(nebula::Map* obj) {
+    return obj->clear();
+}
+
+
+template<>
+inline constexpr protocol::TType Cpp2Ops<nebula::Map>::thriftType() {
+    return apache::thrift::protocol::T_STRUCT;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Map>::write(Protocol* proto, nebula::Map const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->writeStructBegin("Map");
+
+    xfer += proto->writeFieldBegin("kvs", apache::thrift::protocol::T_MAP, 1);
+    xfer += detail::pm::protocol_methods<
+            type_class::map<type_class::binary, type_class::structure>,
+            std::unordered_map<std::string, nebula::Value>
+        >::write(*proto, obj->kvs);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldStop();
+    xfer += proto->writeStructEnd();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+void Cpp2Ops<nebula::Map>::read(Protocol* proto, nebula::Map* obj) {
+    detail::ProtocolReaderStructReadState<Protocol> readState;
+
+    readState.readStructBegin(proto);
+
+    using apache::thrift::TProtocolException;
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 0, 1, protocol::T_MAP))) {
+        goto _loop;
+    }
+
+_readField_kvs:
+    {
+        obj->kvs = std::unordered_map<std::string, nebula::Value>();
+        detail::pm::protocol_methods<
+                type_class::map<type_class::binary, type_class::structure>,
+                std::unordered_map<std::string, nebula::Value>
+            >::read(*proto, obj->kvs);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 1, 0, protocol::T_STOP))) {
+        goto _loop;
+    }
+
+_end:
+    readState.readStructEnd(proto);
+
+    return;
+
+_loop:
+    if (readState.fieldType == apache::thrift::protocol::T_STOP) {
+        goto _end;
+    }
+
+    if (proto->kUsesFieldNames()) {
+        detail::TccStructTraits<nebula::Map>::translateFieldName(
+            readState.fieldName(), readState.fieldId, readState.fieldType);
+    }
+
+    switch (readState.fieldId) {
+        case 1:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_MAP)) {
+                goto _readField_kvs;
+            } else {
+                goto _skip;
+            }
+        }
+        default:
+        {
+_skip:
+            proto->skip(readState.fieldType);
+            readState.readFieldEnd(proto);
+            readState.readFieldBeginNoInline(proto);
+            goto _loop;
+        }
+    }
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Map>::serializedSize(Protocol const* proto,
+                                              nebula::Map const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("Map");
+
+    xfer += proto->serializedFieldSize("kvs", apache::thrift::protocol::T_MAP, 1);
+    xfer += detail::pm::protocol_methods<
+            type_class::map<type_class::binary, type_class::structure>,
+            std::unordered_map<std::string, nebula::Value>
+        >::serializedSize<false>(*proto, obj->kvs);
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Map>::serializedSizeZC(Protocol const* proto,
+                                                nebula::Map const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("Map");
+
+    xfer += proto->serializedFieldSize("kvs", apache::thrift::protocol::T_MAP, 1);
+    xfer += detail::pm::protocol_methods<
+            type_class::map<type_class::binary, type_class::structure>,
+            std::unordered_map<std::string, nebula::Value>
+        >::serializedSize<false>(*proto, obj->kvs);
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+}  // namespace thrift
+}  // namespace apache
+#endif  // DATATYPES_MAPOPS_H_
+
diff --git a/src/datatypes/Path.h b/src/datatypes/Path.h
index 79f6fcf..6c60346 100644
--- a/src/datatypes/Path.h
+++ b/src/datatypes/Path.h
@@ -17,6 +17,12 @@ struct Step {
     EdgeRanking ranking;
     VertexID dst;
 
+    void clear() {
+        type = 0;
+        ranking = 0;
+        dst.clear();
+    }
+
     bool operator==(const Step& rhs) const {
         return type == rhs.type &&
                ranking == rhs.ranking &&
@@ -29,6 +35,11 @@ struct Path {
     VertexID src;
     std::vector<Step> steps;
 
+    void clear() {
+        src.clear();
+        steps.clear();
+    }
+
     bool operator==(const Path& rhs) const {
         return src == rhs.src &&
                steps == rhs.steps;
diff --git a/src/datatypes/PathOps.h b/src/datatypes/PathOps.h
new file mode 100644
index 0000000..600bf62
--- /dev/null
+++ b/src/datatypes/PathOps.h
@@ -0,0 +1,414 @@
+/* Copyright (c) 2020 vesoft inc. All rights reserved.
+ *
+ * This source code is licensed under Apache 2.0 License,
+ * attached with Common Clause Condition 1.0, found in the LICENSES directory.
+ */
+
+#ifndef DATATYPES_PATHOPS_H_
+#define DATATYPES_PATHOPS_H_
+
+#include "base/Base.h"
+
+#include "interface/gen-cpp2/common_types.h"
+
+#include <thrift/lib/cpp2/GeneratedSerializationCodeHelper.h>
+#include <thrift/lib/cpp2/gen/module_types_tcc.h>
+#include <thrift/lib/cpp2/protocol/ProtocolReaderStructReadState.h>
+
+#include "datatypes/Path.h"
+
+namespace apache {
+namespace thrift {
+
+/**************************************
+ *
+ * Ops for class Step
+ *
+ *************************************/
+namespace detail {
+
+template<>
+struct TccStructTraits<nebula::Step> {
+    static void translateFieldName(
+            FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
+            FOLLY_MAYBE_UNUSED int16_t& fid,
+            FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
+        if (_fname == "type") {
+            fid = 1;
+            _ftype = apache::thrift::protocol::T_I32;
+        } else if (_fname == "ranking") {
+            fid = 2;
+            _ftype = apache::thrift::protocol::T_I64;
+        } else if (_fname == "dst") {
+            fid = 3;
+            _ftype = apache::thrift::protocol::T_STRING;
+        }
+    }
+};
+
+}  // namespace detail
+
+
+template<>
+inline void Cpp2Ops<nebula::Step>::clear(nebula::Step* obj) {
+    return obj->clear();
+}
+
+
+template<>
+inline constexpr protocol::TType Cpp2Ops<nebula::Step>::thriftType() {
+    return apache::thrift::protocol::T_STRUCT;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Step>::write(Protocol* proto, nebula::Step const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->writeStructBegin("Step");
+
+    xfer += proto->writeFieldBegin("type", apache::thrift::protocol::T_I32, 1);
+    xfer += detail::pm::protocol_methods<type_class::integral, nebula::EdgeType>
+        ::write(*proto, obj->type);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("ranking", apache::thrift::protocol::T_I64, 2);
+    xfer += detail::pm::protocol_methods<type_class::integral, nebula::EdgeRanking>
+        ::write(*proto, obj->ranking);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("dst", apache::thrift::protocol::T_STRING, 3);
+    xfer += proto->writeBinary(obj->dst);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldStop();
+    xfer += proto->writeStructEnd();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+void Cpp2Ops<nebula::Step>::read(Protocol* proto, nebula::Step* obj) {
+    detail::ProtocolReaderStructReadState<Protocol> readState;
+
+    readState.readStructBegin(proto);
+
+    using apache::thrift::TProtocolException;
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 0, 1, protocol::T_I32))) {
+        goto _loop;
+    }
+
+_readField_type:
+    {
+        detail::pm::protocol_methods<type_class::integral, nebula::EdgeType>
+            ::read(*proto, obj->type);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 1, 2, protocol::T_I64))) {
+        goto _loop;
+    }
+
+_readField_ranking:
+    {
+        detail::pm::protocol_methods<type_class::integral, nebula::EdgeRanking>
+            ::read(*proto, obj->ranking);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 2, 3, protocol::T_STRING))) {
+        goto _loop;
+    }
+
+_readField_dst:
+    {
+        proto->readBinary(obj->dst);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 3, 0, protocol::T_STOP))) {
+        goto _loop;
+    }
+
+_end:
+    readState.readStructEnd(proto);
+
+    return;
+
+_loop:
+    if (readState.fieldType == apache::thrift::protocol::T_STOP) {
+        goto _end;
+    }
+
+    if (proto->kUsesFieldNames()) {
+        detail::TccStructTraits<nebula::Step>::translateFieldName(
+            readState.fieldName(), readState.fieldId, readState.fieldType);
+    }
+
+    switch (readState.fieldId) {
+        case 1:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_I32)) {
+                goto _readField_type;
+            } else {
+                goto _skip;
+            }
+        }
+        case 2:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_I64)) {
+                goto _readField_ranking;
+            } else {
+                goto _skip;
+            }
+        }
+        case 3:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_STRING)) {
+                goto _readField_dst;
+            } else {
+                goto _skip;
+            }
+        }
+        default:
+        {
+_skip:
+            proto->skip(readState.fieldType);
+            readState.readFieldEnd(proto);
+            readState.readFieldBeginNoInline(proto);
+            goto _loop;
+        }
+    }
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Step>::serializedSize(Protocol const* proto,
+                                               nebula::Step const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("Step");
+
+    xfer += proto->serializedFieldSize("type", apache::thrift::protocol::T_I32, 1);
+    xfer += detail::pm::protocol_methods<type_class::integral, nebula::EdgeType>
+        ::serializedSize<false>(*proto, obj->type);
+
+    xfer += proto->serializedFieldSize("ranking", apache::thrift::protocol::T_I64, 2);
+    xfer += detail::pm::protocol_methods<type_class::integral, nebula::EdgeRanking>
+        ::serializedSize<false>(*proto, obj->ranking);
+
+    xfer += proto->serializedFieldSize("dst", apache::thrift::protocol::T_STRING, 3);
+    xfer += proto->serializedSizeBinary(obj->dst);
+
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Step>::serializedSizeZC(Protocol const* proto,
+                                                 nebula::Step const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("Step");
+
+    xfer += proto->serializedFieldSize("type", apache::thrift::protocol::T_I32, 1);
+    xfer += detail::pm::protocol_methods<type_class::integral, nebula::EdgeType>
+        ::serializedSize<false>(*proto, obj->type);
+
+    xfer += proto->serializedFieldSize("ranking", apache::thrift::protocol::T_I64, 2);
+    xfer += detail::pm::protocol_methods<type_class::integral, nebula::EdgeRanking>
+        ::serializedSize<false>(*proto, obj->ranking);
+
+    xfer += proto->serializedFieldSize("dst", apache::thrift::protocol::T_STRING, 3);
+    xfer += proto->serializedSizeBinary(obj->dst);
+
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+
+/**************************************
+ *
+ * Ops for class Path
+ *
+ *************************************/
+namespace detail {
+
+template<>
+struct TccStructTraits<nebula::Path> {
+    static void translateFieldName(
+            FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
+            FOLLY_MAYBE_UNUSED int16_t& fid,
+            FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
+        if (_fname == "src") {
+            fid = 1;
+            _ftype = apache::thrift::protocol::T_STRING;
+        } else if (_fname == "steps") {
+            fid = 2;
+            _ftype = apache::thrift::protocol::T_LIST;
+        }
+    }
+};
+
+}  // namespace detail
+
+
+template<>
+inline void Cpp2Ops<nebula::Path>::clear(nebula::Path* obj) {
+    return obj->clear();
+}
+
+
+template<>
+inline constexpr protocol::TType Cpp2Ops<nebula::Path>::thriftType() {
+    return apache::thrift::protocol::T_STRUCT;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Path>::write(Protocol* proto, nebula::Path const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->writeStructBegin("Path");
+
+    xfer += proto->writeFieldBegin("src", apache::thrift::protocol::T_STRING, 1);
+    xfer += proto->writeBinary(obj->src);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldBegin("steps", apache::thrift::protocol::T_LIST, 2);
+    xfer += detail::pm::protocol_methods<
+            type_class::list<type_class::structure>,
+            std::vector<nebula::Step>
+        >::write(*proto, obj->steps);
+    xfer += proto->writeFieldEnd();
+
+    xfer += proto->writeFieldStop();
+    xfer += proto->writeStructEnd();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+void Cpp2Ops<nebula::Path>::read(Protocol* proto, nebula::Path* obj) {
+    detail::ProtocolReaderStructReadState<Protocol> readState;
+
+    readState.readStructBegin(proto);
+
+    using apache::thrift::TProtocolException;
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 0, 1, protocol::T_STRING))) {
+        goto _loop;
+    }
+
+_readField_src:
+    {
+        proto->readBinary(obj->src);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 1, 2, protocol::T_LIST))) {
+        goto _loop;
+    }
+
+_readField_steps:
+    {
+        obj->steps = std::vector<nebula::Step>();
+        detail::pm::protocol_methods<
+                type_class::list<type_class::structure>,
+                std::vector<nebula::Step>
+            >::read(*proto, obj->steps);
+    }
+
+    if (UNLIKELY(!readState.advanceToNextField(proto, 2, 0, protocol::T_STOP))) {
+        goto _loop;
+    }
+
+_end:
+    readState.readStructEnd(proto);
+
+    return;
+
+_loop:
+    if (readState.fieldType == apache::thrift::protocol::T_STOP) {
+        goto _end;
+    }
+
+    if (proto->kUsesFieldNames()) {
+        detail::TccStructTraits<nebula::Path>::translateFieldName(
+            readState.fieldName(), readState.fieldId, readState.fieldType);
+    }
+
+    switch (readState.fieldId) {
+        case 1:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_STRING)) {
+                goto _readField_src;
+            } else {
+                goto _skip;
+            }
+        }
+        case 2:
+        {
+            if (LIKELY(readState.fieldType == apache::thrift::protocol::T_LIST)) {
+                goto _readField_steps;
+            } else {
+                goto _skip;
+            }
+        }
+        default:
+        {
+_skip:
+            proto->skip(readState.fieldType);
+            readState.readFieldEnd(proto);
+            readState.readFieldBeginNoInline(proto);
+            goto _loop;
+        }
+    }
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Path>::serializedSize(Protocol const* proto,
+                                               nebula::Path const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("Path");
+
+    xfer += proto->serializedFieldSize("src", apache::thrift::protocol::T_STRING, 1);
+    xfer += proto->serializedSizeBinary(obj->src);
+
+    xfer += proto->serializedFieldSize("steps", apache::thrift::protocol::T_LIST, 2);
+    xfer += detail::pm::protocol_methods<
+            type_class::list<type_class::structure>,
+            std::vector<nebula::Step>
+        >::serializedSize<false>(*proto, obj->steps);
+
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Path>::serializedSizeZC(Protocol const* proto,
+                                                 nebula::Path const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("Path");
+
+    xfer += proto->serializedFieldSize("src", apache::thrift::protocol::T_STRING, 1);
+    xfer += proto->serializedSizeZCBinary(obj->src);
+
+    xfer += proto->serializedFieldSize("steps", apache::thrift::protocol::T_LIST, 2);
+    xfer += detail::pm::protocol_methods<
+            type_class::list<type_class::structure>,
+            std::vector<nebula::Step>
+        >::serializedSize<false>(*proto, obj->steps);
+
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+}  // namespace thrift
+}  // namespace apache
+#endif  // DATATYPES_PATHOPS_H_
+
diff --git a/src/datatypes/Value.cpp b/src/datatypes/Value.cpp
index 1ab9aca..08d30d0 100644
--- a/src/datatypes/Value.cpp
+++ b/src/datatypes/Value.cpp
@@ -5,6 +5,8 @@
  */
 
 #include "datatypes/Value.h"
+#include "datatypes/Map.h"
+#include "datatypes/List.h"
 
 namespace nebula {
 
@@ -12,64 +14,54 @@ Value::Value(Value&& rhs) : type_(Value::Type::__EMPTY__) {
     if (this == &rhs) { return; }
     if (rhs.type_ == Type::__EMPTY__) { return; }
     switch (rhs.type_) {
-        case Type::nVal:
+        case Type::NULLVALUE:
         {
-            value_.nVal = std::move(rhs.value_.nVal);
+            setN(std::move(rhs.value_.nVal));
             break;
         }
-        case Type::vVal:
+        case Type::BOOL:
         {
-            value_.vVal = std::move(rhs.value_.vVal);
+            setB(std::move(rhs.value_.bVal));
             break;
         }
-        case Type::bVal:
+        case Type::INT:
         {
-            value_.bVal = std::move(rhs.value_.bVal);
+            setI(std::move(rhs.value_.iVal));
             break;
         }
-        case Type::iVal:
+        case Type::FLOAT:
         {
-            value_.iVal = std::move(rhs.value_.iVal);
+            setF(std::move(rhs.value_.fVal));
             break;
         }
-        case Type::fVal:
+        case Type::STRING:
         {
-            value_.fVal = std::move(rhs.value_.fVal);
+            setS(std::move(rhs.value_.sVal));
             break;
         }
-        case Type::sVal:
+        case Type::DATE:
         {
-            value_.sVal = std::move(rhs.value_.sVal);
+            setD(std::move(rhs.value_.dVal));
             break;
         }
-        case Type::tVal:
+        case Type::DATETIME:
         {
-            value_.tVal = std::move(rhs.value_.tVal);
+            setT(std::move(rhs.value_.tVal));
             break;
         }
-        case Type::dVal:
+        case Type::PATH:
         {
-            value_.dVal = std::move(rhs.value_.dVal);
+            setP(std::move(rhs.value_.pVal));
             break;
         }
-        case Type::dtVal:
+        case Type::LIST:
         {
-            value_.dtVal = std::move(rhs.value_.dtVal);
+            setL(std::move(rhs.value_.lVal));
             break;
         }
-        case Type::pVal:
+        case Type::MAP:
         {
-            value_.pVal = std::move(rhs.value_.pVal);
-            break;
-        }
-        case Type::listVal:
-        {
-            value_.listVal = std::move(rhs.value_.listVal);
-            break;
-        }
-        case Type::mapVal:
-        {
-            value_.mapVal = std::move(rhs.value_.mapVal);
+            setM(std::move(rhs.value_.mVal));
             break;
         }
         default:
@@ -78,7 +70,6 @@ Value::Value(Value&& rhs) : type_(Value::Type::__EMPTY__) {
             break;
         }
     }
-    type_ = rhs.type_;
     rhs.clear();
 }
 
@@ -87,66 +78,54 @@ Value::Value(const Value& rhs) : type_(Value::Type::__EMPTY__) {
     if (this == &rhs) { return; }
     if (rhs.type_ == Type::__EMPTY__) { return; }
     switch (rhs.type_) {
-        case Type::nVal:
-        {
-            value_.nVal = rhs.value_.nVal;
-            break;
-        }
-        case Type::vVal:
+        case Type::NULLVALUE:
         {
-            value_.vVal = rhs.value_.vVal;
+            setN(rhs.value_.nVal);
             break;
         }
-        case Type::bVal:
+        case Type::BOOL:
         {
-            value_.bVal = rhs.value_.bVal;
+            setB(rhs.value_.bVal);
             break;
         }
-        case Type::iVal:
+        case Type::INT:
         {
-            value_.iVal = rhs.value_.iVal;
+            setI(rhs.value_.iVal);
             break;
         }
-        case Type::fVal:
+        case Type::FLOAT:
         {
-            value_.fVal = rhs.value_.fVal;
+            setF(rhs.value_.fVal);
             break;
         }
-        case Type::sVal:
+        case Type::STRING:
         {
-            value_.sVal = rhs.value_.sVal;
+            setS(rhs.value_.sVal);
             break;
         }
-        case Type::tVal:
+        case Type::DATE:
         {
-            value_.tVal = rhs.value_.tVal;
+            setD(rhs.value_.dVal);
             break;
         }
-        case Type::dVal:
+        case Type::DATETIME:
         {
-            value_.dVal = rhs.value_.dVal;
+            setT(rhs.value_.tVal);
             break;
         }
-        case Type::dtVal:
+        case Type::PATH:
         {
-            value_.dtVal = rhs.value_.dtVal;
+            setP(rhs.value_.pVal);
             break;
         }
-        case Type::pVal:
+        case Type::LIST:
         {
-            value_.pVal = rhs.value_.pVal;
+            setL(rhs.value_.lVal);
             break;
         }
-        case Type::listVal:
+        case Type::MAP:
         {
-            value_.listVal = std::make_unique<List>();
-            *value_.listVal = *rhs.value_.listVal;
-            break;
-        }
-        case Type::mapVal:
-        {
-            value_.mapVal = std::make_unique<Map>();
-            *value_.mapVal = *rhs.value_.mapVal;
+            setM(rhs.value_.mVal);
             break;
         }
         default:
@@ -155,60 +134,399 @@ Value::Value(const Value& rhs) : type_(Value::Type::__EMPTY__) {
             break;
         }
     }
-    type_ = rhs.type_;
+}
+
+Value::Value(const NullType& v) {
+    setN(v);
+}
+
+Value::Value(NullType&& v) {
+    setN(std::move(v));
+}
+
+Value::Value(const bool& v) {
+    setB(v);
+}
+
+Value::Value(bool&& v) {
+    setB(std::move(v));
+}
+
+Value::Value(const double& v) {
+    setF(v);
+}
+
+Value::Value(double&& v) {
+    setF(std::move(v));
+}
+
+Value::Value(const std::string& v) {
+    setS(v);
+}
+
+Value::Value(std::string&& v) {
+    setS(std::move(v));
+}
+
+Value::Value(const Date& v) {
+    setD(v);
+}
+
+Value::Value(Date&& v) {
+    setD(std::move(v));
+}
+
+Value::Value(const DateTime& v) {
+    setT(v);
+}
+
+Value::Value(DateTime&& v) {
+    setT(std::move(v));
+}
+
+Value::Value(const Path& v) {
+    setP(v);
+}
+
+Value::Value(Path&& v) {
+    setP(std::move(v));
+}
+
+Value::Value(const List& v) {
+    auto c = std::make_unique<List>(v);
+    setL(std::move(c));
+}
+
+Value::Value(List&& v) {
+    setL(std::make_unique<List>(std::move(v)));
+}
+
+Value::Value(const Map& v) {
+    auto c = std::make_unique<Map>(v);
+    setM(std::move(c));
+}
+
+Value::Value(Map&& v) {
+    setM(std::make_unique<Map>(std::move(v)));
+}
+
+
+void Value::setNull(const NullType& v) {
+    clear();
+    setN(v);
+}
+
+void Value::setNull(NullType&& v) {
+    clear();
+    setN(std::move(v));
+}
+
+void Value::setBool(const bool& v) {
+    clear();
+    setB(v);
+}
+
+void Value::setBool(bool&& v) {
+    clear();
+    setB(std::move(v));
+}
+
+void Value::setInt(const int64_t& v) {
+    clear();
+    setI(v);
+}
+
+void Value::setInt(int64_t&& v) {
+    clear();
+    setI(std::move(v));
+}
+
+void Value::setFloat(const double& v) {
+    clear();
+    setF(v);
+}
+
+void Value::setFloat(double&& v) {
+    clear();
+    setF(std::move(v));
+}
+
+void Value::setStr(const std::string& v) {
+    clear();
+    setS(v);
+}
+
+void Value::setStr(std::string&& v) {
+    clear();
+    setS(std::move(v));
+}
+
+void Value::setDate(const Date& v) {
+    clear();
+    setD(v);
+}
+
+void Value::setDate(Date&& v) {
+    clear();
+    setD(std::move(v));
+}
+
+void Value::setDateTime(const DateTime& v) {
+    clear();
+    setT(v);
+}
+
+void Value::setDateTime(DateTime&& v) {
+    clear();
+    setT(std::move(v));
+}
+
+void Value::setPath(const Path& v) {
+    clear();
+    setP(v);
+}
+
+void Value::setPath(Path&& v) {
+    clear();
+    setP(std::move(v));
+}
+
+void Value::setList(const List& v) {
+    clear();
+    setL(v);
+}
+
+void Value::setList(List&& v) {
+    clear();
+    setL(std::move(v));
+}
+
+void Value::setMap(const Map& v) {
+    clear();
+    setM(v);
+}
+
+void Value::setMap(Map&& v) {
+    clear();
+    setM(std::move(v));
+}
+
+
+const NullType& Value::getNull() const {
+    CHECK_EQ(type_, Type::NULLVALUE);
+    return value_.nVal;
+}
+
+const bool& Value::getBool() const {
+    CHECK_EQ(type_, Type::BOOL);
+    return value_.bVal;
+}
+
+const int64_t& Value::getInt() const {
+    CHECK_EQ(type_, Type::INT);
+    return value_.iVal;
+}
+
+const double& Value::getFloat() const {
+    CHECK_EQ(type_, Type::FLOAT);
+    return value_.fVal;
+}
+
+const std::string& Value::getStr() const {
+    CHECK_EQ(type_, Type::STRING);
+    return value_.sVal;
+}
+
+const Date& Value::getDate() const {
+    CHECK_EQ(type_, Type::DATE);
+    return value_.dVal;
+}
+
+const DateTime& Value::getDateTime() const {
+    CHECK_EQ(type_, Type::DATETIME);
+    return value_.tVal;
+}
+
+const Path& Value::getPath() const {
+    CHECK_EQ(type_, Type::PATH);
+    return value_.pVal;
+}
+
+const List& Value::getList() const {
+    CHECK_EQ(type_, Type::LIST);
+    return *(value_.lVal);
+}
+
+const Map& Value::getMap() const {
+    CHECK_EQ(type_, Type::MAP);
+    return *(value_.mVal);
+}
+
+
+NullType& Value::mutableNull() {
+    CHECK_EQ(type_, Type::NULLVALUE);
+    return value_.nVal;
+}
+
+bool& Value::mutableBool() {
+    CHECK_EQ(type_, Type::BOOL);
+    return value_.bVal;
+}
+
+int64_t& Value::mutableInt() {
+    CHECK_EQ(type_, Type::INT);
+    return value_.iVal;
+}
+
+double& Value::mutableFloat() {
+    CHECK_EQ(type_, Type::FLOAT);
+    return value_.fVal;
+}
+
+std::string& Value::mutableStr() {
+    CHECK_EQ(type_, Type::STRING);
+    return value_.sVal;
+}
+
+Date& Value::mutableDate() {
+    CHECK_EQ(type_, Type::DATE);
+    return value_.dVal;
+}
+
+DateTime& Value::mutableDateTime() {
+    CHECK_EQ(type_, Type::DATETIME);
+    return value_.tVal;
+}
+
+Path& Value::mutablePath() {
+    CHECK_EQ(type_, Type::PATH);
+    return value_.pVal;
+}
+
+List& Value::mutableList() {
+    CHECK_EQ(type_, Type::LIST);
+    return *(value_.lVal);
+}
+
+Map& Value::mutableMap() {
+    CHECK_EQ(type_, Type::MAP);
+    return *(value_.mVal);
+}
+
+
+NullType Value::moveNull() {
+    CHECK_EQ(type_, Type::NULLVALUE);
+    NullType v = std::move(value_.nVal);
+    clear();
+    return std::move(v);
+}
+
+bool Value::moveBool() {
+    CHECK_EQ(type_, Type::BOOL);
+    bool v = std::move(value_.bVal);
+    clear();
+    return std::move(v);
+}
+
+int64_t Value::moveInt() {
+    CHECK_EQ(type_, Type::INT);
+    int64_t v = std::move(value_.iVal);
+    clear();
+    return std::move(v);
+}
+
+double Value::moveFloat() {
+    CHECK_EQ(type_, Type::FLOAT);
+    double v = std::move(value_.fVal);
+    clear();
+    return std::move(v);
+}
+
+std::string Value::moveStr() {
+    CHECK_EQ(type_, Type::STRING);
+    std::string v = std::move(value_.sVal);
+    clear();
+    return std::move(v);
+}
+
+Date Value::moveDate() {
+    CHECK_EQ(type_, Type::DATE);
+    Date v = std::move(value_.dVal);
+    clear();
+    return std::move(v);
+}
+
+DateTime Value::moveDateTime() {
+    CHECK_EQ(type_, Type::DATETIME);
+    DateTime v = std::move(value_.tVal);
+    clear();
+    return std::move(v);
+}
+
+Path Value::movePath() {
+    CHECK_EQ(type_, Type::PATH);
+    Path v = std::move(value_.pVal);
+    clear();
+    return std::move(v);
+}
+
+List Value::moveList() {
+    CHECK_EQ(type_, Type::LIST);
+    List list = std::move(*(value_.lVal));
+    clear();
+    return std::move(list);
+}
+
+Map Value::moveMap() {
+    CHECK_EQ(type_, Type::MAP);
+    Map map = std::move(*(value_.mVal));
+    clear();
+    return std::move(map);
 }
 
 
 bool Value::operator==(const Value& rhs) const {
     if (type_ != rhs.type_) { return false; }
     switch (type_) {
-        case Type::nVal:
+        case Type::NULLVALUE:
         {
           return value_.nVal == rhs.value_.nVal;
         }
-        case Type::vVal:
-        {
-          return value_.vVal == rhs.value_.vVal;
-        }
-        case Type::bVal:
+        case Type::BOOL:
         {
           return value_.bVal == rhs.value_.bVal;
         }
-        case Type::iVal:
+        case Type::INT:
         {
           return value_.iVal == rhs.value_.iVal;
         }
-        case Type::fVal:
+        case Type::FLOAT:
         {
           return value_.fVal == rhs.value_.fVal;
         }
-        case Type::sVal:
+        case Type::STRING:
         {
           return value_.sVal == rhs.value_.sVal;
         }
-        case Type::tVal:
-        {
-          return value_.tVal == rhs.value_.tVal;
-        }
-        case Type::dVal:
+        case Type::DATE:
         {
           return value_.dVal == rhs.value_.dVal;
         }
-        case Type::dtVal:
+        case Type::DATETIME:
         {
-          return value_.dtVal == rhs.value_.dtVal;
+          return value_.tVal == rhs.value_.tVal;
         }
-        case Type::pVal:
+        case Type::PATH:
         {
           return value_.pVal == rhs.value_.pVal;
         }
-        case Type::listVal:
+        case Type::LIST:
         {
-          return *value_.listVal == *rhs.value_.listVal;
+          return *value_.lVal == *rhs.value_.lVal;
         }
-        case Type::mapVal:
+        case Type::MAP:
         {
-          return *value_.mapVal == *rhs.value_.mapVal;
+          return *value_.mVal == *rhs.value_.mVal;
         }
         default:
         {
@@ -220,69 +538,58 @@ bool Value::operator==(const Value& rhs) const {
 
 void Value::clear() {
     switch (type_) {
-        case Type::nVal:
+        case Type::__EMPTY__:
         {
-            destruct(value_.nVal);
-            break;
+            return;
         }
-        case Type::vVal:
+        case Type::NULLVALUE:
         {
-            destruct(value_.vVal);
+            destruct(value_.nVal);
             break;
         }
-        case Type::bVal:
+        case Type::BOOL:
         {
             destruct(value_.bVal);
             break;
         }
-        case Type::iVal:
+        case Type::INT:
         {
             destruct(value_.iVal);
             break;
         }
-        case Type::fVal:
+        case Type::FLOAT:
         {
             destruct(value_.fVal);
             break;
         }
-        case Type::sVal:
+        case Type::STRING:
         {
             destruct(value_.sVal);
             break;
         }
-        case Type::tVal:
-        {
-            destruct(value_.tVal);
-            break;
-        }
-        case Type::dVal:
+        case Type::DATE:
         {
             destruct(value_.dVal);
             break;
         }
-        case Type::dtVal:
+        case Type::DATETIME:
         {
-            destruct(value_.dtVal);
+            destruct(value_.tVal);
             break;
         }
-        case Type::pVal:
+        case Type::PATH:
         {
             destruct(value_.pVal);
             break;
         }
-        case Type::listVal:
+        case Type::LIST:
         {
-            destruct(value_.listVal);
+            destruct(value_.lVal);
             break;
         }
-        case Type::mapVal:
+        case Type::MAP:
         {
-            destruct(value_.mapVal);
-            break;
-        }
-        default:
-        {
-            assert(false);
+            destruct(value_.mVal);
             break;
         }
     }
@@ -295,64 +602,54 @@ Value& Value::operator=(Value&& rhs) {
     clear();
     if (rhs.type_ == Type::__EMPTY__) { return *this; }
     switch (rhs.type_) {
-        case Type::nVal:
+        case Type::NULLVALUE:
         {
-            value_.nVal = std::move(rhs.value_.nVal);
+            setN(std::move(rhs.value_.nVal));
             break;
         }
-        case Type::vVal:
+        case Type::BOOL:
         {
-            value_.vVal = std::move(rhs.value_.vVal);
+            setB(std::move(rhs.value_.bVal));
             break;
         }
-        case Type::bVal:
+        case Type::INT:
         {
-            value_.bVal = std::move(rhs.value_.bVal);
+            setI(std::move(rhs.value_.iVal));
             break;
         }
-        case Type::iVal:
+        case Type::FLOAT:
         {
-            value_.iVal = std::move(rhs.value_.iVal);
+            setF(std::move(rhs.value_.fVal));
             break;
         }
-        case Type::fVal:
+        case Type::STRING:
         {
-            value_.fVal = std::move(rhs.value_.fVal);
+            setS(std::move(rhs.value_.sVal));
             break;
         }
-        case Type::sVal:
+        case Type::DATE:
         {
-            value_.sVal = std::move(rhs.value_.sVal);
+            setD(std::move(rhs.value_.dVal));
             break;
         }
-        case Type::tVal:
+        case Type::DATETIME:
         {
-            value_.tVal = std::move(rhs.value_.tVal);
+            setT(std::move(rhs.value_.tVal));
             break;
         }
-        case Type::dVal:
+        case Type::PATH:
         {
-            value_.dVal = std::move(rhs.value_.dVal);
+            setP(std::move(rhs.value_.pVal));
             break;
         }
-        case Type::dtVal:
+        case Type::LIST:
         {
-            value_.dtVal = std::move(rhs.value_.dtVal);
+            setL(std::move(rhs.value_.lVal));
             break;
         }
-        case Type::pVal:
+        case Type::MAP:
         {
-            value_.pVal = std::move(rhs.value_.pVal);
-            break;
-        }
-        case Type::listVal:
-        {
-            value_.listVal = std::move(rhs.value_.listVal);
-            break;
-        }
-        case Type::mapVal:
-        {
-            value_.mapVal = std::move(rhs.value_.mapVal);
+            setM(std::move(rhs.value_.mVal));
             break;
         }
         default:
@@ -361,7 +658,6 @@ Value& Value::operator=(Value&& rhs) {
             break;
         }
     }
-    type_ = rhs.type_;
     rhs.clear();
     return *this;
 }
@@ -372,66 +668,54 @@ Value& Value::operator=(const Value& rhs) {
     clear();
     if (rhs.type_ == Type::__EMPTY__) { return *this; }
     switch (rhs.type_) {
-        case Type::nVal:
-        {
-            value_.nVal = rhs.value_.nVal;
-            break;
-        }
-        case Type::vVal:
+        case Type::NULLVALUE:
         {
-            value_.vVal = rhs.value_.vVal;
+            setN(rhs.value_.nVal);
             break;
         }
-        case Type::bVal:
+        case Type::BOOL:
         {
-            value_.bVal = rhs.value_.bVal;
+            setB(rhs.value_.bVal);
             break;
         }
-        case Type::iVal:
+        case Type::INT:
         {
-            value_.iVal = rhs.value_.iVal;
+            setI(rhs.value_.iVal);
             break;
         }
-        case Type::fVal:
+        case Type::FLOAT:
         {
-            value_.fVal = rhs.value_.fVal;
+            setF(rhs.value_.fVal);
             break;
         }
-        case Type::sVal:
+        case Type::STRING:
         {
-            value_.sVal = rhs.value_.sVal;
+            setS(rhs.value_.sVal);
             break;
         }
-        case Type::tVal:
+        case Type::DATE:
         {
-            value_.tVal = rhs.value_.tVal;
+            setD(rhs.value_.dVal);
             break;
         }
-        case Type::dVal:
+        case Type::DATETIME:
         {
-            value_.dVal = rhs.value_.dVal;
+            setT(rhs.value_.tVal);
             break;
         }
-        case Type::dtVal:
+        case Type::PATH:
         {
-            value_.dtVal = rhs.value_.dtVal;
+            setP(rhs.value_.pVal);
             break;
         }
-        case Type::pVal:
+        case Type::LIST:
         {
-            value_.pVal = rhs.value_.pVal;
+            setL(rhs.value_.lVal);
             break;
         }
-        case Type::listVal:
+        case Type::MAP:
         {
-            value_.listVal = std::make_unique<List>();
-            *value_.listVal = *rhs.value_.listVal;
-            break;
-        }
-        case Type::mapVal:
-        {
-            value_.mapVal = std::make_unique<Map>();
-            *value_.mapVal = *rhs.value_.mapVal;
+            setM(rhs.value_.mVal);
             break;
         }
         default:
@@ -445,12 +729,189 @@ Value& Value::operator=(const Value& rhs) {
 }
 
 
+void Value::setN(const NullType& v) {
+    type_ = Type::NULLVALUE;
+    new (std::addressof(value_.nVal)) NullType(v);
+}
+
+void Value::setN(NullType&& v) {
+    type_ = Type::NULLVALUE;
+    new (std::addressof(value_.nVal)) NullType(std::move(v));
+}
+
+void Value::setB(const bool& v) {
+    type_ = Type::BOOL;
+    new (std::addressof(value_.bVal)) bool(v);                  // NOLINT
+}
+
+void Value::setB(bool&& v) {
+    type_ = Type::BOOL;
+    new (std::addressof(value_.bVal)) bool(std::move(v));       // NOLINT
+}
+
+void Value::setI(const int64_t& v) {
+    type_ = Type::INT;
+    new (std::addressof(value_.iVal)) int64_t(v);               // NOLINT
+}
+
+void Value::setI(int64_t&& v) {
+    type_ = Type::INT;
+    new (std::addressof(value_.iVal)) int64_t(std::move(v));    // NOLINT
+}
+
+void Value::setF(const double& v) {
+    type_ = Type::FLOAT;
+    new (std::addressof(value_.fVal)) double(v);                // NOLINT
+}
+
+void Value::setF(double&& v) {
+    type_ = Type::FLOAT;
+    new (std::addressof(value_.fVal)) double(std::move(v));     // NOLINT
+}
+
+void Value::setS(const std::string& v) {
+    type_ = Type::STRING;
+    new (std::addressof(value_.sVal)) std::string(v);
+}
+
+void Value::setS(std::string&& v) {
+    type_ = Type::STRING;
+    new (std::addressof(value_.sVal)) std::string(std::move(v));
+}
+
+void Value::setD(const Date& v) {
+    type_ = Type::DATE;
+    new (std::addressof(value_.dVal)) Date(v);
+}
+
+void Value::setD(Date&& v) {
+    type_ = Type::DATE;
+    new (std::addressof(value_.dVal)) Date(std::move(v));
+}
+
+void Value::setT(const DateTime& v) {
+    type_ = Type::DATETIME;
+    new (std::addressof(value_.tVal)) DateTime(v);
+}
+
+void Value::setT(DateTime&& v) {
+    type_ = Type::DATETIME;
+    new (std::addressof(value_.tVal)) DateTime(std::move(v));
+}
+
+void Value::setP(const Path& v) {
+    type_ = Type::PATH;
+    new (std::addressof(value_.pVal)) Path(v);
+}
+
+void Value::setP(Path&& v) {
+    type_ = Type::PATH;
+    new (std::addressof(value_.pVal)) Path(std::move(v));
+}
+
+void Value::setL(const std::unique_ptr<List>& v) {
+    type_ = Type::LIST;
+    new (std::addressof(value_.lVal)) std::unique_ptr<List>(new List(*v));
+}
+
+void Value::setL(std::unique_ptr<List>&& v) {
+    type_ = Type::LIST;
+    new (std::addressof(value_.lVal)) std::unique_ptr<List>(std::move(v));
+}
+
+void Value::setL(const List& v) {
+    type_ = Type::LIST;
+    new (std::addressof(value_.lVal)) std::unique_ptr<List>(new List(v));
+}
+
+void Value::setL(List&& v) {
+    type_ = Type::LIST;
+    new (std::addressof(value_.lVal)) std::unique_ptr<List>(new List(std::move(v)));
+}
+
+void Value::setM(const std::unique_ptr<Map>& v) {
+    type_ = Type::MAP;
+    new (std::addressof(value_.mVal)) std::unique_ptr<Map>(new Map(*v));
+}
+
+void Value::setM(std::unique_ptr<Map>&& v) {
+    type_ = Type::MAP;
+    new (std::addressof(value_.mVal)) std::unique_ptr<Map>(std::move(v));
+}
+
+void Value::setM(const Map& v) {
+    type_ = Type::MAP;
+    new (std::addressof(value_.mVal)) std::unique_ptr<Map>(new Map(v));
+}
+
+void Value::setM(Map&& v) {
+    type_ = Type::MAP;
+    new (std::addressof(value_.mVal)) std::unique_ptr<Map>(new Map(std::move(v)));
+}
+
+
 void swap(Value& a, Value& b) {
   Value temp(std::move(a));
   a = std::move(b);
   b = std::move(temp);
 }
 
+
+std::ostream& operator<<(std::ostream& os, const Value::Type& type) {
+    switch (type) {
+        case Value::Type::__EMPTY__: {
+            os << "__EMPTY__";
+            break;
+        }
+        case Value::Type::NULLVALUE: {
+            os << "NULL";
+            break;
+        }
+        case Value::Type::BOOL: {
+            os << "BOOL";
+            break;
+        }
+        case Value::Type::INT: {
+            os << "INT";
+            break;
+        }
+        case Value::Type::FLOAT: {
+            os << "FLOAT";
+            break;
+        }
+        case Value::Type::STRING: {
+            os << "STRING";
+            break;
+        }
+        case Value::Type::DATE: {
+            os << "DATE";
+            break;
+        }
+        case Value::Type::DATETIME: {
+            os << "DATETIME";
+            break;
+        }
+        case Value::Type::PATH: {
+            os << "PATH";
+            break;
+        }
+        case Value::Type::LIST: {
+            os << "LIST";
+            break;
+        }
+        case Value::Type::MAP: {
+            os << "MAP";
+            break;
+        }
+        default: {
+            os << "__UNKNOWN__";
+            break;
+        }
+    }
+
+    return os;
+}
+
 }  // namespace nebula
 
 
diff --git a/src/datatypes/Value.h b/src/datatypes/Value.h
index 27be95a..01624f3 100644
--- a/src/datatypes/Value.h
+++ b/src/datatypes/Value.h
@@ -12,92 +12,221 @@
 #include "datatypes/Date.h"
 #include "datatypes/Path.h"
 
+namespace apache {
+namespace thrift {
+
+template<class T, class U>
+class Cpp2Ops;
+
+}  // namespace thrift
+}  // namespace apache
+
+
 namespace nebula {
 
 struct Map;
 struct List;
 
 enum class NullType {
-    NT_Null = 0,
-    NT_NaN = 1,
-    NT_BadType = 2
+    __NULL__ = 0,
+    NaN      = 1,
+    BAD_DATA = 2,
+    BAD_TYPE = 3
 };
 
 
 struct Value {
-    enum Type {
-        __EMPTY__ = 0,
-        nVal = 1,
-        vVal = 2,
-        bVal = 3,
-        iVal = 4,
-        fVal = 5,
-        sVal = 6,
-        tVal = 7,
-        dVal = 8,
-        dtVal = 9,
-        pathVal = 10,
-        listVal = 11,
-        mapVal = 12,
-    } type_;
-
-    union Storage {
-        NullType                nVal;
-        VertexID                vVal;
-        bool                    bVal;
-        int64_t                 iVal;
-        double                  fVal;
-        std::string             sVal;
-        Timestamp               tVal;
-        Date                    dVal;
-        DateTime                dtVal;
-        Path                    pVal;
-        std::unique_ptr<List>   listVal;
-        std::unique_ptr<Map>    mapVal;
+    friend class apache::thrift::Cpp2Ops<Value, void>;
 
-        Storage() {}
-        ~Storage() {}
-    } value_;
+    enum class Type {
+        __EMPTY__ = 0,
+        NULLVALUE = 1,
+        BOOL = 2,
+        INT = 3,
+        FLOAT = 4,
+        STRING = 5,
+        DATE = 6,
+        DATETIME = 7,
+        PATH = 8,
+        LIST = 9,
+        MAP = 10,
+    };
 
     // Constructors
     Value() : type_(Type::__EMPTY__) {}
     Value(Value&& rhs);
     Value(const Value& rhs);
 
-    bool operator==(const Value& rhs) const;
+    Value(const NullType& v);       // NOLINT
+    Value(NullType&& v);            // NOLINT
+    Value(const bool& v);           // NOLINT
+    Value(bool&& v);                // NOLINT
+    Value(const double& v);         // NOLINT
+    Value(double&& v);              // NOLINT
+    Value(const std::string& v);    // NOLINT
+    Value(std::string&& v);         // NOLINT
+    Value(const Date& v);           // NOLINT
+    Value(Date&& v);                // NOLINT
+    Value(const DateTime& v);       // NOLINT
+    Value(DateTime&& v);            // NOLINT
+    Value(const Path& v);           // NOLINT
+    Value(Path&& v);                // NOLINT
+    Value(const List& v);           // NOLINT
+    Value(List&& v);                // NOLINT
+    Value(const Map& v);            // NOLINT
+    Value(Map&& v);                 // NOLINT
+    // We need a template here to support multiple integer types
+    template<
+        typename T,
+        typename = typename std::enable_if<std::is_integral<T>::value>::type
+    >
+    Value(T&& v) {             // NOLINT
+        setI(std::forward<T>(v));
+    }
 
-    Value& operator=(Value&& rhs);
-    Value& operator=(const Value& rhs);
+    Type type() const noexcept {
+        return type_;
+    }
 
-private:
-  template <class T>
-  void destruct(T& val) {
-    (&val)->~T();
-  }
+    void clear();
 
-  void clear();
-};
+    Value& operator=(Value&& rhs);
+    Value& operator=(const Value& rhs);
 
-void swap(Value& a, Value& b);
+    void setNull(const NullType& v);
+    void setNull(NullType&& v);
+    void setBool(const bool& v);
+    void setBool(bool&& v);
+    void setInt(const int64_t& v);
+    void setInt(int64_t&& v);
+    void setFloat(const double& v);
+    void setFloat(double&& v);
+    void setStr(const std::string& v);
+    void setStr(std::string&& v);
+    void setDate(const Date& v);
+    void setDate(Date&& v);
+    void setDateTime(const DateTime& v);
+    void setDateTime(DateTime&& v);
+    void setPath(const Path& v);
+    void setPath(Path&& v);
+    void setList(const List& v);
+    void setList(List&& v);
+    void setMap(const Map& v);
+    void setMap(Map&& v);
+    // We need a template here to support multiple integer types
+    template<
+        typename T,
+        typename = typename std::enable_if<std::is_integral<T>::value>::type
+    >
+    void setInt(T&& v) {
+        clear();
+        setI(std::forward<T>(v));
+    }
 
+    const NullType& getNull() const;
+    const bool& getBool() const;
+    const int64_t& getInt() const;
+    const double& getFloat() const;
+    const std::string& getStr() const;
+    const Date& getDate() const;
+    const DateTime& getDateTime() const;
+    const Path& getPath() const;
+    const List& getList() const;
+    const Map& getMap() const;
+
+    NullType moveNull();
+    bool moveBool();
+    int64_t moveInt();
+    double moveFloat();
+    std::string moveStr();
+    Date moveDate();
+    DateTime moveDateTime();
+    Path movePath();
+    List moveList();
+    Map moveMap();
+
+    NullType& mutableNull();
+    bool& mutableBool();
+    int64_t& mutableInt();
+    double& mutableFloat();
+    std::string& mutableStr();
+    Date& mutableDate();
+    DateTime& mutableDateTime();
+    Path& mutablePath();
+    List& mutableList();
+    Map& mutableMap();
 
-struct Map {
-    std::unordered_map<std::string, Value> kvs;
+    bool operator==(const Value& rhs) const;
 
-    bool operator==(const Map& rhs) const {
-        return kvs == rhs.kvs;
+    static const Value& null() noexcept {
+        static const Value kNullValue(NullType::__NULL__);
+        return kNullValue;
     }
-};
 
+private:
+    Type type_;
+
+    union Storage {
+        NullType                nVal;
+        bool                    bVal;
+        int64_t                 iVal;
+        double                  fVal;
+        std::string             sVal;
+        Date                    dVal;
+        DateTime                tVal;
+        Path                    pVal;
+        std::unique_ptr<List>   lVal;
+        std::unique_ptr<Map>    mVal;
 
-struct List {
-    std::vector<Value> values;
+        Storage() {}
+        ~Storage() {}
+    } value_;
 
-    bool operator==(const List& rhs) const {
-        return values == rhs.values;
+    template <class T>
+    void destruct(T& val) {
+        (&val)->~T();
     }
+
+    // Null value
+    void setN(const NullType& v);
+    void setN(NullType&& v);
+    // Bool value
+    void setB(const bool& v);
+    void setB(bool&& v);
+    // Integer value
+    void setI(const int64_t& v);
+    void setI(int64_t&& v);
+    // Double float value
+    void setF(const double& v);
+    void setF(double&& v);
+    // String value
+    void setS(const std::string& v);
+    void setS(std::string&& v);
+    // Date value
+    void setD(const Date& v);
+    void setD(Date&& v);
+    // DateTime value
+    void setT(const DateTime& v);
+    void setT(DateTime&& v);
+    // Path value
+    void setP(const Path& v);
+    void setP(Path&& v);
+    // List value
+    void setL(const std::unique_ptr<List>& v);
+    void setL(std::unique_ptr<List>&& v);
+    void setL(const List& v);
+    void setL(List&& v);
+    // Map value
+    void setM(const std::unique_ptr<Map>& v);
+    void setM(std::unique_ptr<Map>&& v);
+    void setM(const Map& v);
+    void setM(Map&& v);
 };
 
+void swap(Value& a, Value& b);
+
+std::ostream& operator<<(std::ostream& os, const Value::Type& type);
+
 }  // namespace nebula
 #endif  // DATATYPES_VALUE_H_
 
diff --git a/src/datatypes/ValueOps.h b/src/datatypes/ValueOps.h
new file mode 100644
index 0000000..305cf6c
--- /dev/null
+++ b/src/datatypes/ValueOps.h
@@ -0,0 +1,497 @@
+/* Copyright (c) 2020 vesoft inc. All rights reserved.
+ *
+ * This source code is licensed under Apache 2.0 License,
+ * attached with Common Clause Condition 1.0, found in the LICENSES directory.
+ */
+
+#ifndef DATATYPES_VALUEOPS_H_
+#define DATATYPES_VALUEOPS_H_
+
+#include "base/Base.h"
+
+#include "interface/gen-cpp2/common_types.h"
+
+#include <thrift/lib/cpp2/GeneratedSerializationCodeHelper.h>
+#include <thrift/lib/cpp2/gen/module_types_tcc.h>
+#include <thrift/lib/cpp2/protocol/ProtocolReaderStructReadState.h>
+
+#include "datatypes/Value.h"
+
+namespace apache {
+namespace thrift {
+
+namespace detail {
+
+template<>
+struct TccStructTraits<nebula::Value> {
+    static void translateFieldName(
+            FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
+            FOLLY_MAYBE_UNUSED int16_t& fid,
+            FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) {
+        if (_fname == "nVal") {
+            fid = 1;
+            _ftype = apache::thrift::protocol::T_I32;
+        } else if (_fname == "bVal") {
+            fid = 2;
+            _ftype = apache::thrift::protocol::T_BOOL;
+        } else if (_fname == "iVal") {
+            fid = 3;
+            _ftype = apache::thrift::protocol::T_I64;
+        } else if (_fname == "fVal") {
+            fid = 4;
+            _ftype = apache::thrift::protocol::T_DOUBLE;
+        } else if (_fname == "sVal") {
+            fid = 5;
+            _ftype = apache::thrift::protocol::T_STRING;
+        } else if (_fname == "dVal") {
+            fid = 6;
+            _ftype = apache::thrift::protocol::T_STRUCT;
+        } else if (_fname == "tVal") {
+            fid = 7;
+            _ftype = apache::thrift::protocol::T_STRUCT;
+        } else if (_fname == "pVal") {
+            fid = 8;
+            _ftype = apache::thrift::protocol::T_STRUCT;
+        } else if (_fname == "lVal") {
+            fid = 9;
+            _ftype = apache::thrift::protocol::T_STRUCT;
+        } else if (_fname == "mVal") {
+            fid = 10;
+            _ftype = apache::thrift::protocol::T_STRUCT;
+        }
+    }
+};
+
+}  // namespace detail
+
+
+template<>
+inline void Cpp2Ops<nebula::Value>::clear(nebula::Value* obj) {
+    return obj->clear();
+}
+
+
+template<>
+inline constexpr apache::thrift::protocol::TType Cpp2Ops<nebula::Value>::thriftType() {
+    return apache::thrift::protocol::T_STRUCT;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Value>::write(Protocol* proto, nebula::Value const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->writeStructBegin("Value");
+    switch (obj->type()) {
+        case nebula::Value::Type::NULLVALUE:
+        {
+            xfer += proto->writeFieldBegin("nVal", apache::thrift::protocol::T_I32, 1);
+            xfer += detail::pm::protocol_methods<type_class::enumeration,
+                                                 nebula::NullType>
+                ::write(*proto, obj->value_.nVal);
+            xfer += proto->writeFieldEnd();
+            break;
+        }
+        case nebula::Value::Type::BOOL:
+        {
+            xfer += proto->writeFieldBegin("bVal", apache::thrift::protocol::T_BOOL, 2);
+            xfer += proto->writeBool(obj->value_.bVal);
+            xfer += proto->writeFieldEnd();
+            break;
+        }
+        case nebula::Value::Type::INT:
+        {
+            xfer += proto->writeFieldBegin("iVal", apache::thrift::protocol::T_I64, 3);
+            xfer += detail::pm::protocol_methods<type_class::integral, int64_t>
+                ::write(*proto, obj->value_.iVal);
+            xfer += proto->writeFieldEnd();
+            break;
+        }
+        case nebula::Value::Type::FLOAT:
+        {
+            xfer += proto->writeFieldBegin("fVal", apache::thrift::protocol::T_DOUBLE, 4);
+            xfer += proto->writeDouble(obj->value_.fVal);
+            xfer += proto->writeFieldEnd();
+            break;
+        }
+        case nebula::Value::Type::STRING:
+        {
+            xfer += proto->writeFieldBegin("sVal", apache::thrift::protocol::T_STRING, 5);
+            xfer += proto->writeBinary(obj->value_.sVal);
+            xfer += proto->writeFieldEnd();
+            break;
+        }
+        case nebula::Value::Type::DATE:
+        {
+            xfer += proto->writeFieldBegin("dVal", apache::thrift::protocol::T_STRUCT, 6);
+            xfer += Cpp2Ops<nebula::Date>::write(proto, &obj->value_.dVal);
+            xfer += proto->writeFieldEnd();
+            break;
+        }
+        case nebula::Value::Type::DATETIME:
+        {
+            xfer += proto->writeFieldBegin("tVal", apache::thrift::protocol::T_STRUCT, 7);
+            xfer += Cpp2Ops<nebula::DateTime>::write(proto, &obj->value_.tVal);
+            xfer += proto->writeFieldEnd();
+            break;
+        }
+        case nebula::Value::Type::PATH:
+        {
+            xfer += proto->writeFieldBegin("pVal", apache::thrift::protocol::T_STRUCT, 8);
+            xfer += Cpp2Ops<nebula::Path>::write(proto, &obj->value_.pVal);
+            xfer += proto->writeFieldEnd();
+            break;
+        }
+        case nebula::Value::Type::LIST:
+        {
+            xfer += proto->writeFieldBegin("lVal", apache::thrift::protocol::T_STRUCT, 9);
+            if (obj->value_.lVal) {
+                xfer += Cpp2Ops<nebula::List>::write(proto, obj->value_.lVal.get());
+            } else {
+                xfer += proto->writeStructBegin("List");
+                xfer += proto->writeStructEnd();
+                xfer += proto->writeFieldStop();
+            }
+            xfer += proto->writeFieldEnd();
+            break;
+        }
+        case nebula::Value::Type::MAP:
+        {
+            xfer += proto->writeFieldBegin("mVal", apache::thrift::protocol::T_STRUCT, 10);
+            if (obj->value_.mVal) {
+                xfer += Cpp2Ops<nebula::Map>::write(proto, obj->value_.mVal.get());
+            } else {
+                xfer += proto->writeStructBegin("Map");
+                xfer += proto->writeStructEnd();
+                xfer += proto->writeFieldStop();
+            }
+            xfer += proto->writeFieldEnd();
+            break;
+        }
+        case nebula::Value::Type::__EMPTY__: {}
+    }
+    xfer += proto->writeFieldStop();
+    xfer += proto->writeStructEnd();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+void Cpp2Ops<nebula::Value>::read(Protocol* proto, nebula::Value* obj) {
+    detail::ProtocolReaderStructReadState<Protocol> readState;
+    readState.fieldId = 0;
+
+    readState.readStructBegin(proto);
+
+    using apache::thrift::TProtocolException;
+
+    readState.readFieldBegin(proto);
+    if (readState.fieldType == protocol::T_STOP) {
+        obj->clear();
+    } else {
+        if (proto->kUsesFieldNames()) {
+            detail::TccStructTraits<nebula::Value>
+                  ::translateFieldName(readState.fieldName(),
+                                       readState.fieldId,
+                                       readState.fieldType);
+        }
+        switch (readState.fieldId) {
+            case 1:
+            {
+                if (readState.fieldType == apache::thrift::protocol::T_I32) {
+                    obj->setNull(nebula::NullType());
+                    detail::pm::protocol_methods<type_class::enumeration, nebula::NullType>
+                        ::read(*proto, obj->value_.nVal);
+              } else {
+                    proto->skip(readState.fieldType);
+              }
+              break;
+            }
+            case 2:
+            {
+                if (readState.fieldType == apache::thrift::protocol::T_BOOL) {
+                    obj->setBool(false);
+                    proto->readBool(obj->value_.bVal);
+                } else {
+                    proto->skip(readState.fieldType);
+                }
+                break;
+            }
+            case 3:
+            {
+                if (readState.fieldType == apache::thrift::protocol::T_I64) {
+                    obj->setInt(0);
+                    detail::pm::protocol_methods<type_class::integral, int64_t>
+                        ::read(*proto, obj->value_.iVal);
+                } else {
+                    proto->skip(readState.fieldType);
+                }
+                break;
+            }
+            case 4:
+            {
+                if (readState.fieldType == apache::thrift::protocol::T_DOUBLE) {
+                    obj->setFloat(0.0);
+                    proto->readDouble(obj->value_.fVal);
+                } else {
+                    proto->skip(readState.fieldType);
+                }
+                break;
+            }
+            case 5:
+            {
+                if (readState.fieldType == apache::thrift::protocol::T_STRING) {
+                    obj->setStr(std::string());
+                    proto->readBinary(obj->value_.sVal);
+                } else {
+                    proto->skip(readState.fieldType);
+                }
+                break;
+            }
+            case 6:
+            {
+                if (readState.fieldType == apache::thrift::protocol::T_STRUCT) {
+                    obj->setDate(nebula::Date());
+                    Cpp2Ops<nebula::Date>::read(proto, &obj->value_.dVal);
+                } else {
+                    proto->skip(readState.fieldType);
+                }
+                break;
+            }
+            case 7:
+            {
+                if (readState.fieldType == apache::thrift::protocol::T_STRUCT) {
+                    obj->setDateTime(nebula::DateTime());
+                    Cpp2Ops<nebula::DateTime>::read(proto, &obj->value_.tVal);
+                } else {
+                    proto->skip(readState.fieldType);
+                }
+                break;
+            }
+            case 8:
+            {
+                if (readState.fieldType == apache::thrift::protocol::T_STRUCT) {
+                    obj->setPath(nebula::Path());
+                    Cpp2Ops<nebula::Path>::read(proto, &obj->value_.pVal);
+                } else {
+                    proto->skip(readState.fieldType);
+                }
+                break;
+            }
+            case 9:
+            {
+                if (readState.fieldType == apache::thrift::protocol::T_STRUCT) {
+                    obj->setList(nebula::List());
+                    std::unique_ptr<nebula::List> ptr = std::make_unique<nebula::List>();
+                    Cpp2Ops<nebula::List>::read(proto, ptr.get());
+                    obj->value_.lVal = std::move(ptr);
+                } else {
+                    proto->skip(readState.fieldType);
+                }
+                break;
+            }
+            case 10:
+            {
+                if (readState.fieldType == apache::thrift::protocol::T_STRUCT) {
+                    obj->setMap(nebula::Map());
+                    std::unique_ptr<nebula::Map> ptr = std::make_unique<nebula::Map>();
+                    Cpp2Ops<nebula::Map>::read(proto, ptr.get());
+                    obj->value_.mVal = std::move(ptr);
+                } else {
+                    proto->skip(readState.fieldType);
+                }
+                break;
+            }
+            default:
+            {
+                proto->skip(readState.fieldType);
+                break;
+            }
+        }
+        readState.readFieldEnd(proto);
+        readState.readFieldBegin(proto);
+        if (UNLIKELY(readState.fieldType != apache::thrift::protocol::T_STOP)) {
+            using apache::thrift::protocol::TProtocolException;
+            TProtocolException::throwUnionMissingStop();
+        }
+    }
+    readState.readStructEnd(proto);
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Value>::serializedSize(Protocol const* proto,
+                                                nebula::Value const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("Value");
+    switch (obj->type()) {
+        case nebula::Value::Type::NULLVALUE:
+        {
+            xfer += proto->serializedFieldSize("nVal", apache::thrift::protocol::T_I32, 1);
+            xfer += detail::pm::protocol_methods<type_class::enumeration, nebula::NullType>
+                ::serializedSize<false>(*proto, obj->value_.nVal);
+            break;
+        }
+        case nebula::Value::Type::BOOL:
+        {
+            xfer += proto->serializedFieldSize("bVal", apache::thrift::protocol::T_BOOL, 2);
+            xfer += proto->serializedSizeBool(obj->value_.bVal);
+            break;
+        }
+        case nebula::Value::Type::INT:
+        {
+            xfer += proto->serializedFieldSize("iVal", apache::thrift::protocol::T_I64, 3);
+            xfer += detail::pm::protocol_methods<type_class::integral, int64_t>
+                ::serializedSize<false>(*proto, obj->value_.iVal);
+          break;
+        }
+        case nebula::Value::Type::FLOAT:
+        {
+            xfer += proto->serializedFieldSize("fVal", apache::thrift::protocol::T_DOUBLE, 4);
+            xfer += proto->serializedSizeDouble(obj->value_.fVal);
+            break;
+        }
+        case nebula::Value::Type::STRING:
+        {
+            xfer += proto->serializedFieldSize("sVal", apache::thrift::protocol::T_STRING, 5);
+            xfer += proto->serializedSizeBinary(obj->value_.sVal);
+            break;
+        }
+        case nebula::Value::Type::DATE:
+        {
+            xfer += proto->serializedFieldSize("dVal", apache::thrift::protocol::T_STRUCT, 6);
+            xfer += Cpp2Ops<nebula::Date>::serializedSize(proto, &obj->value_.dVal);
+            break;
+        }
+        case nebula::Value::Type::DATETIME:
+        {
+            xfer += proto->serializedFieldSize("tVal", apache::thrift::protocol::T_STRUCT, 7);
+            xfer += Cpp2Ops<nebula::DateTime>::serializedSize(proto, &obj->value_.tVal);
+            break;
+        }
+        case nebula::Value::Type::PATH:
+        {
+            xfer += proto->serializedFieldSize("pVal", apache::thrift::protocol::T_STRUCT, 8);
+            xfer += Cpp2Ops<nebula::Path>::serializedSize(proto, &obj->value_.pVal);
+            break;
+        }
+        case nebula::Value::Type::LIST:
+        {
+            xfer += proto->serializedFieldSize("lVal", apache::thrift::protocol::T_STRUCT, 9);
+            if (obj->value_.lVal) {
+                xfer += Cpp2Ops<nebula::List>::serializedSize(proto, obj->value_.lVal.get());
+            } else {
+                xfer += proto->serializedStructSize("List");
+                xfer += proto->serializedSizeStop();
+            }
+            break;
+        }
+        case nebula::Value::Type::MAP:
+        {
+            xfer += proto->serializedFieldSize("mVal", apache::thrift::protocol::T_STRUCT, 10);
+            if (obj->value_.mVal) {
+                xfer += Cpp2Ops<nebula::Map>::serializedSize(proto, obj->value_.mVal.get());
+            } else {
+                xfer += proto->serializedStructSize("Map");
+                xfer += proto->serializedSizeStop();
+            }
+            break;
+        }
+        case nebula::Value::Type::__EMPTY__: {}
+    }
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+
+template<>
+template<class Protocol>
+uint32_t Cpp2Ops<nebula::Value>::serializedSizeZC(Protocol const* proto,
+                                                  nebula::Value const* obj) {
+    uint32_t xfer = 0;
+    xfer += proto->serializedStructSize("Value");
+    switch (obj->type()) {
+        case nebula::Value::Type::NULLVALUE:
+        {
+            xfer += proto->serializedFieldSize("nVal", apache::thrift::protocol::T_I32, 1);
+            xfer += detail::pm::protocol_methods<type_class::enumeration, nebula::NullType>
+                ::serializedSize<false>(*proto, obj->value_.nVal);
+            break;
+        }
+        case nebula::Value::Type::BOOL:
+        {
+            xfer += proto->serializedFieldSize("bVal", apache::thrift::protocol::T_BOOL, 2);
+            xfer += proto->serializedSizeBool(obj->value_.bVal);
+            break;
+        }
+        case nebula::Value::Type::INT:
+        {
+            xfer += proto->serializedFieldSize("iVal", apache::thrift::protocol::T_I64, 3);
+            xfer += detail::pm::protocol_methods<type_class::integral, int64_t>
+                ::serializedSize<false>(*proto, obj->value_.iVal);
+            break;
+        }
+        case nebula::Value::Type::FLOAT:
+        {
+            xfer += proto->serializedFieldSize("fVal", apache::thrift::protocol::T_DOUBLE, 4);
+            xfer += proto->serializedSizeDouble(obj->value_.fVal);
+            break;
+        }
+        case nebula::Value::Type::STRING:
+        {
+            xfer += proto->serializedFieldSize("sVal", apache::thrift::protocol::T_STRING, 5);
+            xfer += proto->serializedSizeZCBinary(obj->value_.sVal);
+            break;
+        }
+        case nebula::Value::Type::DATE:
+        {
+            xfer += proto->serializedFieldSize("dVal", apache::thrift::protocol::T_STRUCT, 6);
+            xfer += Cpp2Ops<nebula::Date>::serializedSizeZC(proto, &obj->value_.dVal);
+            break;
+        }
+        case nebula::Value::Type::DATETIME:
+        {
+            xfer += proto->serializedFieldSize("tVal", apache::thrift::protocol::T_STRUCT, 7);
+            xfer += Cpp2Ops<nebula::DateTime>::serializedSizeZC(proto, &obj->value_.tVal);
+            break;
+        }
+        case nebula::Value::Type::PATH:
+        {
+            xfer += proto->serializedFieldSize("pVal", apache::thrift::protocol::T_STRUCT, 8);
+            xfer += Cpp2Ops<nebula::Path>::serializedSizeZC(proto, &obj->value_.pVal);
+            break;
+        }
+        case nebula::Value::Type::LIST:
+        {
+            xfer += proto->serializedFieldSize("lVal", apache::thrift::protocol::T_STRUCT, 9);
+            if (obj->value_.lVal) {
+                xfer += Cpp2Ops<nebula::List>::serializedSizeZC(proto, obj->value_.lVal.get());
+            } else {
+                xfer += proto->serializedStructSize("List");
+                xfer += proto->serializedSizeStop();
+            }
+            break;
+        }
+        case nebula::Value::Type::MAP:
+        {
+            xfer += proto->serializedFieldSize("mVal", apache::thrift::protocol::T_STRUCT, 10);
+            if (obj->value_.mVal) {
+                xfer += Cpp2Ops<nebula::Map>::serializedSizeZC(proto, obj->value_.mVal.get());
+            } else {
+                xfer += proto->serializedStructSize("Map");
+                xfer += proto->serializedSizeStop();
+            }
+            break;
+        }
+        case nebula::Value::Type::__EMPTY__: {}
+    }
+    xfer += proto->serializedSizeStop();
+    return xfer;
+}
+
+}  // namespace thrift
+}  // namespace apache
+#endif  // DATATYPES_VALUEOPS_H_
+
diff --git a/src/interface/common.thrift b/src/interface/common.thrift
index 59c7246..b05b68c 100644
--- a/src/interface/common.thrift
+++ b/src/interface/common.thrift
@@ -10,11 +10,13 @@ namespace java com.vesoft.nebula
 namespace go nebula
 
 cpp_include "thrift/ThriftTypes.h"
-cpp_include "datatypes/Date.h"
-cpp_include "datatypes/Path.h"
-cpp_include "datatypes/Value.h"
-cpp_include "datatypes/KeyValue.h"
-cpp_include "datatypes/HostAddr.h"
+cpp_include "datatypes/DateOps.h"
+cpp_include "datatypes/PathOps.h"
+cpp_include "datatypes/ValueOps.h"
+cpp_include "datatypes/MapOps.h"
+cpp_include "datatypes/ListOps.h"
+cpp_include "datatypes/KeyValueOps.h"
+cpp_include "datatypes/HostAddrOps.h"
 
 /*
  *
@@ -28,7 +30,7 @@ typedef i32 (cpp.type = "nebula::PartitionID") PartitionID
 typedef i32 (cpp.type = "nebula::TagID") TagID
 typedef i32 (cpp.type = "nebula::EdgeType") EdgeType
 typedef i64 (cpp.type = "nebula::EdgeRanking") EdgeRanking
-typedef i64 (cpp.type = "nebula::VertexID") VertexID
+typedef binary (cpp.type = "nebula::VertexID") VertexID
 
 typedef i64 (cpp.type = "nebula::Timestamp") Timestamp
 
@@ -73,26 +75,25 @@ struct Path {
 
 
 enum NullType {
-    NT_Null     = 0,
-    NT_NaN      = 1,
-    NT_BadType  = 2,
+    __NULL__ = 0,
+    NaN      = 1,
+    BAD_DATA = 2,
+    BAD_TYPE = 3,
 } (cpp.enum_strict cpp.type = "nebula::NullType")
 
 
 // The type to hold any supported values during the query
 union Value {
     1: NullType                             nVal;
-    2: VertexID                             vVal;
-    3: bool                                 bVal;
-    4: i64                                  iVal;
-    5: double                               fVal;
-    6: binary                               sVal;
-    7: Timestamp                            tVal;
-    8: Date                                 dVal;
-    9: DateTime                             dtVal;
-    10: Path                                pVal;
-    11: List (cpp.type = "nebula::List")    listVal (cpp.ref_type = "unique");
-    12: Map (cpp.type = "nebula::Map")      mapVal (cpp.ref_type = "unique");
+    2: bool                                 bVal;
+    3: i64                                  iVal;
+    4: double                               fVal;
+    5: binary                               sVal;
+    6: Date                                 dVal;
+    7: DateTime                             tVal;
+    8: Path                                 pVal;
+    9: List (cpp.type = "nebula::List")     lVal (cpp.ref_type = "unique");
+    10: Map (cpp.type = "nebula::Map")      mVal (cpp.ref_type = "unique");
 } (cpp.type = "nebula::Value")
 
 
diff --git a/src/interface/meta.thrift b/src/interface/meta.thrift
index 4ebb955..f58502d 100644
--- a/src/interface/meta.thrift
+++ b/src/interface/meta.thrift
@@ -130,10 +130,10 @@ enum PropertyType {
 struct ColumnDef {
     1: required binary          name,
     2: required PropertyType    type,
+    3: optional common.Value    default_value,
     // type_length is valid for fixed_string type
-    3: required i16             type_length = 0,
-    4: required bool            nullable = false,
-    5: optional common.Value    default_value,
+    4: optional i16             type_length = 0,
+    5: optional bool            nullable = false,
 }
 
 struct SchemaProp {
@@ -155,6 +155,7 @@ struct SpaceProperties {
     1: binary   space_name,
     2: i32      partition_num,
     3: i32      replica_factor,
+    4: i32      vid_size = 8,
 }
 
 struct SpaceItem {
diff --git a/src/meta/GflagsManager.h b/src/meta/GflagsManager.h
index aeff3b4..cbd6d39 100644
--- a/src/meta/GflagsManager.h
+++ b/src/meta/GflagsManager.h
@@ -10,7 +10,7 @@
 #include "base/Base.h"
 #include "base/Status.h"
 #include "base/StatusOr.h"
-#include "gen-cpp2/MetaServiceAsyncClient.h"
+#include "interface/gen-cpp2/MetaServiceAsyncClient.h"
 
 namespace nebula {
 namespace meta {
diff --git a/src/meta/NebulaSchemaProvider.cpp b/src/meta/NebulaSchemaProvider.cpp
index 2440a69..b7a550b 100644
--- a/src/meta/NebulaSchemaProvider.cpp
+++ b/src/meta/NebulaSchemaProvider.cpp
@@ -37,7 +37,7 @@ const char* NebulaSchemaProvider::getFieldName(int64_t index) const {
         return nullptr;
     }
 
-    return fields_[index]->getName();
+    return fields_[index]->name();
 }
 
 
@@ -47,7 +47,7 @@ const cpp2::PropertyType NebulaSchemaProvider::getFieldType(int64_t index) const
         return cpp2::PropertyType::UNKNOWN;
     }
 
-    return fields_[index]->getType();
+    return fields_[index]->type();
 }
 
 
@@ -59,7 +59,7 @@ const cpp2::PropertyType NebulaSchemaProvider::getFieldType(const folly::StringP
         return cpp2::PropertyType::UNKNOWN;
     }
 
-    return fields_[it->second]->getType();
+    return fields_[it->second]->type();
 }
 
 
diff --git a/src/meta/NebulaSchemaProvider.h b/src/meta/NebulaSchemaProvider.h
index 17cc01a..ab478fa 100644
--- a/src/meta/NebulaSchemaProvider.h
+++ b/src/meta/NebulaSchemaProvider.h
@@ -23,11 +23,11 @@ public:
             : name_(std::move(name))
             , type_(std::move(type)) {}
 
-        const char* getName() const override {
+        const char* name() const override {
             return name_.c_str();
         }
 
-        const cpp2::PropertyType getType() const override {
+        const cpp2::PropertyType type() const override {
             return type_;
         }
 
@@ -39,7 +39,7 @@ public:
             return hasDefault_;
         }
 
-        std::string getDefaultValue() const override {
+        const Value& defaultValue() const override {
             return defaultValue_;
         }
 
@@ -47,7 +47,7 @@ public:
         std::string name_;
         cpp2::PropertyType type_;
         bool hasDefault_;
-        std::string defaultValue_;
+        Value defaultValue_;
     };
 
 public:
@@ -79,9 +79,9 @@ protected:
     SchemaVer ver_{-1};
 
     // fieldname -> index
-    std::unordered_map<std::string, int64_t>   fieldNameIndex_;
-    std::vector<std::shared_ptr<SchemaField>>  fields_;
-    cpp2::SchemaProp                   schemaProp_;
+    std::unordered_map<std::string, int64_t>    fieldNameIndex_;
+    std::vector<std::shared_ptr<SchemaField>>   fields_;
+    cpp2::SchemaProp                            schemaProp_;
 };
 
 }  // namespace meta
diff --git a/src/meta/SchemaProviderIf.h b/src/meta/SchemaProviderIf.h
index 2d0a9ce..64d794b 100644
--- a/src/meta/SchemaProviderIf.h
+++ b/src/meta/SchemaProviderIf.h
@@ -8,7 +8,7 @@
 #define META_SCHEMAPROVIDERIF_H_
 
 #include "base/Base.h"
-#include "gen-cpp2/meta_types.h"
+#include "interface/gen-cpp2/meta_types.h"
 
 
 namespace nebula {
@@ -21,11 +21,11 @@ public:
     public:
         virtual ~Field() = default;
 
-        virtual const char* getName() const = 0;
-        virtual const cpp2::PropertyType getType() const = 0;
+        virtual const char* name() const = 0;
+        virtual const cpp2::PropertyType type() const = 0;
         virtual bool isValid() const = 0;
         virtual bool hasDefault() const = 0;
-        virtual std::string getDefaultValue() const = 0;
+        virtual const Value& defaultValue() const = 0;
     };
 
     // Inherited classes do not need to implement the Iterator
diff --git a/src/thrift/ThriftTypes.h b/src/thrift/ThriftTypes.h
index 1803ce1..2cf8079 100644
--- a/src/thrift/ThriftTypes.h
+++ b/src/thrift/ThriftTypes.h
@@ -22,7 +22,14 @@ using Port = int32_t;
 
 using TagIndexID = int32_t;
 using EdgeIndexID = int32_t;
-using VertexID = int64_t;
+// Starting from 2.0, both string and int64 vertex ids will be supported.
+//
+// The string id must be fixed-length (the length of the id will be specified
+// as a Graph Space property). So the int64 id will be treated as 8-byte string
+//
+// If the length of a given id is shorter than the specified length, '\0' will
+// be appended to the end
+using VertexID = std::string;
 using TagID = int32_t;
 using TagVersion = int64_t;
 using EdgeType = int32_t;
